<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Accord.Math</name>
    </assembly>
    <members>
        <member name="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno">
            <summary>
              Limited-memory Broyden–Fletcher–Goldfarb–Shanno (L-BFGS) optimization method.
            </summary>
            <remarks>
            <para>
              The L-BFGS algorithm is a member of the broad family of quasi-Newton optimization
              methods. L-BFGS stands for 'Limited memory BFGS'. Indeed, L-BFGS uses a limited
              memory variation of the Broyden–Fletcher–Goldfarb–Shanno (BFGS) update to approximate
              the inverse Hessian matrix (denoted by Hk). Unlike the original BFGS method which
              stores a dense  approximation, L-BFGS stores only a few vectors that represent the
              approximation implicitly. Due to its moderate memory requirement, L-BFGS method is
              particularly well suited for optimization problems with a large number of variables.</para>
            <para>
              L-BFGS never explicitly forms or stores Hk. Instead, it maintains a history of the past
              <c>m</c> updates of the position <c>x</c> and gradient <c>g</c>, where generally the history
              <c>m</c>can be short, often less than 10. These updates are used to implicitly do operations
              requiring the Hk-vector product.</para>
              
            <para>
              The framework implementation of this method is based on the original FORTRAN source code
              by Jorge Nocedal (see references below). The original FORTRAN source code of LBFGS (for
              unconstrained problems) is available at http://www.netlib.org/opt/lbfgs_um.shar and had
              been made available under the public domain. </para>
            
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://www.netlib.org/opt/lbfgs_um.shar">
                   Jorge Nocedal. Limited memory BFGS method for large scale optimization (Fortran source code). 1990.
                   Available in http://www.netlib.org/opt/lbfgs_um.shar </a></description></item>
                <item><description>
                   Jorge Nocedal. Updating Quasi-Newton Matrices with Limited Storage. <i>Mathematics of Computation</i>,
                   Vol. 35, No. 151, pp. 773--782, 1980.</description></item>
                <item><description>
                   Dong C. Liu, Jorge Nocedal. On the limited memory BFGS method for large scale optimization.</description></item>
               </list></para>
            </remarks>
            
            <example>
            <para>
              The following example shows the basic usage of the L-BFGS solver
              to find the minimum of a function specifying its function and
              gradient. </para>
              
            <code>
            // Suppose we would like to find the minimum of the function
            // 
            //   f(x,y)  =  -exp{-(x-1)²} - exp{-(y-2)²/2}
            //
            
            // First we need write down the function either as a named
            // method, an anonymous method or as a lambda function:
            
            Func&lt;double[], double> f = (x) =>
                -Math.Exp(-Math.Pow(x[0] - 1, 2)) - Math.Exp(-0.5 * Math.Pow(x[1] - 2, 2));
            
            // Now, we need to write its gradient, which is just the
            // vector of first partial derivatives del_f / del_x, as:
            //
            //   g(x,y)  =  { del f / del x, del f / del y }
            // 
            
            Func&lt;double[], double[]> g = (x) => new double[] 
            {
                // df/dx = {-2 e^(-    (x-1)^2) (x-1)}
                2 * Math.Exp(-Math.Pow(x[0] - 1, 2)) * (x[0] - 1),
            
                // df/dy = {-  e^(-1/2 (y-2)^2) (y-2)}
                Math.Exp(-0.5 * Math.Pow(x[1] - 2, 2)) * (x[1] - 2)
            };
            
            // Finally, we can create the L-BFGS solver, passing the functions as arguments
            var lbfgs = new BroydenFletcherGoldfarbShanno(numberOfVariables: 2, function: f, gradient: g);
            
            // And then minimize the function:
            double minValue = lbfgs.Minimize();
            double[] solution = lbfgs.Solution;
            
            // The resultant minimum value should be -2, and the solution
            // vector should be { 1.0, 2.0 }. The answer can be checked on
            // Wolfram Alpha by clicking the following the link:
            
            // http://www.wolframalpha.com/input/?i=maximize+%28exp%28-%28x-1%29%C2%B2%29+%2B+exp%28-%28y-2%29%C2%B2%2F2%29%29
            
            </code>
            </example>
            
        </member>
        <member name="T:Accord.Math.Optimization.IOptimizationMethod">
            <summary>
              Common interface for function optimization methods.
            </summary>
            
            <seealso cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
            
        </member>
        <member name="M:Accord.Math.Optimization.IOptimizationMethod.Minimize(System.Double[])">
            <summary>
              Optimizes the defined function. 
            </summary>
            
            <param name="values">The initial guess values for the parameters.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.IOptimizationMethod.Solution">
            <summary>
              Gets the solution found, the values of the parameters which
              optimizes the function.
            </summary>
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.#ctor(System.Int32)">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]},System.Func{System.Double[]})">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            <param name="diagonal">The diagonal of the Hessian.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Minimize">
            <summary>
              Minimizes the defined function. 
            </summary>
            
            <returns>The minimum value found at the <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Solution"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Minimize(System.Double[])">
            <summary>
              Minimizes the defined function. 
            </summary>
            
            <param name="values">The initial guess values for the parameters. Default is the zero vector.</param>
            
            <returns>The minimum value found at the <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Solution"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.mcsrch(System.Double[],System.Double@,System.Double[]@,System.Double*,System.Double@,System.Int32@,System.Double[])">
            <summary>
              Finds a step which satisfies a sufficient decrease and curvature condition.
            </summary>
            
        </member>
        <member name="E:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Progress">
            <summary>
              Occurs when progress is made during the optimization.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Function">
            <summary>
              Gets or sets the function to be optimized.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Gradient">
            <summary>
              Gets or sets a function returning the gradient
              vector of the function to be optimized for a
              given value of its free parameters.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Diagonal">
            <summary>
              Gets or sets a function returning the Hessian
              diagonals to be used during optimization.
            </summary>
            
            <value>A function for the Hessian diagonal.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Parameters">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Iterations">
            <summary>
              Gets the number of iterations performed in the last
              call to <see cref="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Minimize"/>.
            </summary>
            
            <value>
              The number of iterations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.MaxIterations">
            <summary>
              Gets or sets the maximum number of iterations
              to be performed during optimization. Default
              is 0 (iterate until convergence).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Evaluations">
            <summary>
              Gets the number of function evaluations performed
              in the last call to <see cref="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Minimize"/>.
            </summary>
            
            <value>
              The number of evaluations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Corrections">
            <summary>
              Gets or sets the number of corrections used in the L-BFGS
              update. Recommended values are between 3 and 7. Default is 5.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.UpperBounds">
            <summary>
              Gets or sets the upper bounds of the interval
              in which the solution must be found.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.LowerBounds">
            <summary>
              Gets or sets the lower bounds of the interval
              in which the solution must be found.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Tolerance">
            <summary>
              Gets or sets the accuracy with which the solution
              is to be found. Default value is 1e-10.
            </summary>
            
            <remarks>
              The optimization routine terminates when ||G|| &lt; EPS max(1,||X||),
              where ||.|| denotes the Euclidean norm and EPS is the value for this
              property.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Precision">
            <summary>
              Gets or sets a tolerance value controlling the accuracy of the
              line search routine. If the function and gradient evaluations are
              inexpensive with respect to the cost of the iteration (which is
              sometimes the case when solving very large problems) it may be
              advantageous to set this to a small value. A typical small value
              is 0.1. This value should be greater than 1e-4. Default is 0.9.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Solution">
            <summary>
              Gets the solution found, the values of the
              parameters which optimizes the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Value">
            <summary>
              Gets the output of the function at the current solution.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Normal">
            <summary>
              Normal distribution functions.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  George Marsaglia, Evaluating the Normal Distribution, 2004.
                  Available in: http://www.jstatsoft.org/v11/a05/paper </description></item>
              </list>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Normal.Function(System.Double)">
            <summary>
              Normal cumulative distribution function.
            </summary>
            <returns>
              The area under the Gaussian p.d.f. integrated
              from minus infinity to the given value.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Normal.Inverse(System.Double)">
            <summary>
               Normal (Gaussian) inverse cumulative distribution function.
            </summary>
            
            <remarks>
            <para>
               For small arguments <c>0 &lt; y &lt; exp(-2)</c>, the program computes <c>z =
               sqrt( -2.0 * log(y) )</c>;  then the approximation is <c>x = z - log(z)/z  - 
               (1/z) P(1/z) / Q(1/z)</c>.</para>
            <para>
               There are two rational functions P/Q, one for <c>0 &lt; y &lt; exp(-32)</c> and
               the other for <c>y</c> up to <c>exp(-2)</c>. For larger arguments, <c>w = y - 0.5</c>,
               and  <c>x/sqrt(2pi) = w + w^3 * R(w^2)/S(w^2))</c>.</para>
            </remarks>
            
            <returns>
               Returns the value, <c>x</c>, for which the area under the Normal (Gaussian)
               probability density function (integrated from minus infinity to <c>x</c>) is
               equal to the argument <c>y</c> (assumes mean is zero, variance is one).
            </returns>
            
        </member>
        <member name="M:Accord.Math.Normal.HighAccuracyFunction(System.Double)">
            <summary>
              High-accuracy Normal cumulative distribution function.
            </summary>
            
            <remarks>
            <para>
              The following formula provide probabilites with an absolute error
              less than 8e-16.</para>
            <para>
              References:
               - George Marsaglia, Evaluating the Normal Distribution, 2004.
                 Available in: http://www.jstatsoft.org/v11/a05/paper </para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Normal.HighAccuracyComplemented(System.Double)">
            <summary>
              High-accuracy Complementary normal distribution function.
            </summary>
            
            <remarks>
            <para>
              This function uses 9 tabled values to provide tail values of the
              normal distribution, also known as complementary Phi, with an
              absolute error of 1e-14 ~ 1e-16.
            </para>
              References:
               - George Marsaglia, Evaluating the Normal Distribution, 2004.
                 Available in: http://www.jstatsoft.org/v11/a05/paper
            </remarks>
            
            <returns>
              The area under the Gaussian p.d.f. integrated
              from the given value to positive infinity.
            </returns>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedCholeskyDecompositionF">
            <summary>
                   Cholesky Decomposition of a symmetric, positive definite matrix.
               </summary>
            <remarks>
              <para>
                   For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                   lower triangular matrix <c>L</c> so that <c>A = L * L'</c>. The presented algorithm
                   only checks the upper triangular part of the matrix given as parameter and assumes
                   it is symmetric. If the matrix is not positive definite, the constructor returns a 
                   partial decomposition and sets two internal variables that can be queried using the
                   <see cref="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="T:Accord.Math.Decompositions.ISolverArrayDecomposition`1">
            <summary>
              Common interface for matrix decompositions which
              can be used to solve linear systems of equations
              involving jagged array matrices.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverArrayDecomposition`1.Solve(`0[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverArrayDecomposition`1.Solve(`0[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverArrayDecomposition`1.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new Cholesky Decomposition.
            </summary>
            
            <param name="value">
              The symmetric matrix, given in upper triangular form, to be decomposed.</param>
            <param name="robust">
              True to perform a square-root free LDLt decomposition, false otherwise.</param>
            <param name="inPlace">
              True to perform the decomposition in place, storing the factorization in the
              lower triangular part of the given matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[][],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.InverseDiagonal(System.Boolean)">
            <summary>
              Computes the diagonal of the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.InverseDiagonal(System.Single[],System.Boolean)">
             <summary>
               Computes the diagonal of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the proccess. Pass false otherwise.</param>
             <param name="result">The array to hold the result of the 
                computation. Should be of same length as the the diagonal
                of the original matrix.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.InverseTrace(System.Boolean)">
             <summary>
               Computes the trace of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the proccess. Pass false otherwise.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.FromLeftTriangularMatrix(System.Single[][])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.PositiveDefinite">
            <summary>
              Returns <see langword="true"/> if the matrix is positive definite.
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.IsNotDefined">
            <summary>
              Gets a value indicating whether the LDLt factorization
              has been computed successfully or if it is undefined.
            </summary>
            
            <value>
                <c>true</c> if the factorization is not defined; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.LeftTriangularFactor">
            <summary>
              Returns the left (lower) triangular factor
              <c>L</c> so that <c>A = L * D * L'</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.DiagonalMatrix">
            <summary>
              Returns the block diagonal matrix of diagonal
              elements in a LDLt decomposition.
            </summary>        
              
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Diagonal">
            <summary>
              Returns the one-dimensional array of diagonal 
              elements in a LDLt decomposition.
            </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Determinant">
            <summary>
              Returns the determinant of
              the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.LogDeterminant">
            <summary>
              If the matrix is positive-definite, returns the
              log-determinant of the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Nonsingular">
            <summary>
              Gets a value indicating whether the decomposed
              matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.BrentSearch">
            <summary>
              Brent's root finding and minimization algorithms.
            </summary>
            
            <remarks>
            <para>
              In numerical analysis, Brent's method is a complicated but popular root-finding 
              algorithm combining the bisection method, the secant method and inverse quadratic
              interpolation. It has the reliability of bisection but it can be as quick as some
              of the less reliable methods. The idea is to use the secant method or inverse quadratic 
              interpolation if possible, because they converge faster, but to fall back to the more
              robust bisection method if necessary. Brent's method is due to Richard Brent (1973)
              and builds on an earlier algorithm of Theodorus Dekker (1969).</para>
              
            <para>
              The algorithms implemented in this class are based on the original C source code
              available in Netlib (http://www.netlib.org/c/brent.shar) by Oleg Keselyov, 1991.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  R.P. Brent (1973). Algorithms for Minimization without Derivatives, Chapter 4. 
                  Prentice-Hall, Englewood Cliffs, NJ. ISBN 0-13-022335-2. </description></item>
                <item><description><a href="http://en.wikipedia.org/wiki/Brent's_method">
                  Wikipedia contributors. "Brent's method." Wikipedia, The Free Encyclopedia.
                  Wikipedia, The Free Encyclopedia, 11 May. 2012. Web. 22 Jun. 2012. </a></description></item>
              </list>
            </para>   
            
            </remarks>
            
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
              Construts a new Brent search algorithm.
            </summary>
            
            <param name="function">The function to be searched.</param>
            <param name="a">Start of search region.</param>
            <param name="b">End of search region.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.FindRoot">
            <summary>
              Attempts to find a root in the interval [a;b] 
            </summary>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Minimize">
            <summary>
              Finds the minimum of the function in the interval [a;b]
            </summary>
            
            <returns>The location of the minimum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Maximize">
            <summary>
              Finds the maximum of the function in the interval [a;b]
            </summary>
            
            <returns>The location of the maximum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Minimize(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Finds the minimum of a function in the interval [a;b]
            </summary>
            
            <param name="f">The function to be minimized.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            
            <returns>The location of the minimum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Maximize(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Finds the maximum of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to be maximized.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            
            <returns>The location of the maximum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.FindRoot(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Finds the root of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to have its root computed.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Tolerance">
            <summary>
              Gets or sets the tolerace margin when
              looking for an answer. Default is 1e-6.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.LowerBound">
            <summary>
              Gets or sets the lower bound for the search interval <c>a</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.UpperBound">
            <summary>
              Gets or sets the lower bound for the search interval <c>a</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Solution">
            <summary>
              Gets the solution found in the last call
              to <see cref="M:Accord.Math.Optimization.BrentSearch.Minimize"/>, <see cref="M:Accord.Math.Optimization.BrentSearch.Maximize"/>
              or <see cref="M:Accord.Math.Optimization.BrentSearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Value">
            <summary>
              Gets the value at the solution found in the last call
              to <see cref="M:Accord.Math.Optimization.BrentSearch.Minimize"/>, <see cref="M:Accord.Math.Optimization.BrentSearch.Maximize"/>
              or <see cref="M:Accord.Math.Optimization.BrentSearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Function">
            <summary>
              Gets the function to be searched.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Matrix">
            <summary>
              Static class Matrix. Defines a set of extension methods
              that operates mainly on multidimensional arrays and vectors.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[0:,0:])">
            <summary>
              Returns a <see cref="T:System.String"/> represents a matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[0:,0:],System.Boolean,Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="multiline">
              If set to <c>true</c>, the matrix will be written using multiple
              lines. If set to <c>false</c>, the matrix will be written in a 
              single line.</param>
              
            <param name="provider">
              The <see cref="T:Accord.Math.Formats.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[0:,0:],Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.Formats.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[0:,0:],System.String,Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            <param name="provider">
              The <see cref="T:Accord.Math.Formats.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[0:,0:],System.String)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[][])">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[][],Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="provider">
              The <see cref="T:Accord.Math.Formats.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[][],System.String,Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            <param name="provider">
              The <see cref="T:Accord.Math.Formats.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[][],System.String)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[])">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="array">The array.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[],Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="array">The array.</param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.Formats.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[],System.String,Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.Formats.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[],System.String)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="array">The array.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Parse(System.String)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
            </summary>
            <param name="str">The string representation of the matrix.</param>
            <returns>A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Parse(System.String,Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
            </summary>
            <param name="str">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <returns>A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ParseJagged(System.String,Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
            </summary>
            <param name="s">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <returns>A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TryParse(System.String,Accord.Math.Formats.IMatrixFormatProvider,System.Double[0:,0:]@)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
              A return value indicates whether the conversion succeeded or failed.
            </summary>
            <param name="s">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <param name="matrix">A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</param>
            <result>When this method returns, contains the double-precision floating-point
            number matrix equivalent to the <see param="s"/> parameter, if the conversion succeeded, 
            or null if the conversion failed. The conversion fails if the <see param="s"/> parameter
            is null, is not a matrix in a valid format, or contains elements which represent
            a number less than MinValue or greater than MaxValue. This parameter is passed
            uninitialized. </result>
            
        </member>
        <member name="M:Accord.Math.Matrix.TryParse(System.String,Accord.Math.Formats.IMatrixFormatProvider,System.Double[][]@)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
              A return value indicates whether the conversion succeeded or failed.
            </summary>
            <param name="s">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <param name="matrix">A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</param>
            <result>When this method returns, contains the double-precision floating-point
            number matrix equivalent to the <see param="s"/> parameter, if the conversion succeeded, 
            or null if the conversion failed. The conversion fails if the <see param="s"/> parameter
            is null, is not a matrix in a valid format, or contains elements which represent
            a number less than MinValue or greater than MaxValue. This parameter is passed
            uninitialized. </result>
            
        </member>
        <member name="M:Accord.Math.Matrix.Create``1(System.Int32,System.Int32,``0)">
            <summary>
              Returns a matrix with all elements set to a given value.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Create``1(System.Int32,``0)">
            <summary>
              Returns a matrix with all elements set to a given value.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,``0)">
            <summary>
              Returns a square diagonal matrix of the given size.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,System.Int32,``0)">
            <summary>
              Returns a matrix of the given size with value on its diagonal.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(``0[])">
            <summary>
              Return a square matrix with a vector of values on its diagonal.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,``0[])">
            <summary>
              Return a square matrix with a vector of values on its diagonal.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,System.Int32,``0[])">
            <summary>
              Returns a matrix with a vector of values on its diagonal.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Identity(System.Int32)">
            <summary>
              Returns the Identity matrix of the given size.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Magic(System.Int32)">
            <summary>
              Creates a magic square matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Centering(System.Int32)">
            <summary>
              Creates a centering matrix of size <c>N x N</c> in the
              form <c>(I - 1N)</c> where <c>1N</c> is a matrix with 
              all elements equal to <c>1 / N</c>.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Int32)">
            <summary>
              Creates a rows-by-cols matrix with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Boolean,System.Double,System.Double)">
            <summary>
              Creates a rows-by-cols matrix with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
              Creates a rows-by-cols matrix with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Int32,AForge.Math.Random.IRandomNumberGenerator)">
            <summary>
              Creates a rows-by-cols matrix random data drawn from a given distribution.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Single,System.Single)">
            <summary>
              Creates a vector with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Double,System.Double)">
            <summary>
              Creates a vector with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,AForge.Math.Random.IRandomNumberGenerator)">
            <summary>
              Creates a vector with random data drawn from a given distribution.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.RowVector``1(``0[])">
            <summary>
              Creates a matrix with a single row vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ColumnVector``1(``0[])">
            <summary>
              Creates a matrix with a single column vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Vector``1(System.Int32,``0[])">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Vector``1(System.Int32,``0)">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Indices(System.Int32,System.Int32)">
            <summary>
              Creates a index vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Int32,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Interval(AForge.DoubleRange,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Double,System.Double,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Single,System.Single,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Interval(AForge.DoubleRange,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Double,System.Double,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Mesh(AForge.DoubleRange,AForge.DoubleRange,System.Double,System.Double)">
            <summary>
              Creates a bidimensional mesh matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[],``0[])">
            <summary>
              Combines two vectors horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[],``0)">
            <summary>
              Combines a vector and a element horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0,``0[])">
            <summary>
              Combines a vector and a element horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[0:,0:],``0[])">
            <summary>
              Combines a matrix and a vector horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[][0:,0:])">
            <summary>
              Combines a matrix and a vector horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[][])">
            <summary>
              Combine vectors horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[][])">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[])">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[],``0)">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[][0:,0:])">
            <summary>
              Combines matrices vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[0:,0:],``0[])">
            <summary>
              Combines matrices vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[][][])">
            <summary>
              Combines matrices vertically.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Expand``1(``0[],System.Int32[])">
            <summary>
              Expands a data vector given in summary form.
            </summary>
            <param name="vector">A base vector.</param>
            <param name="count">An array containing by how much each line should be replicated.</param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.Expand``1(``0[0:,0:],System.Int32[])">
            <summary>
              Expands a data matrix given in summary form.
            </summary>
            <param name="matrix">A base matrix.</param>
            <param name="count">An array containing by how much each line should be replicated.</param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.Split``1(``0[],System.Int32)">
            <summary>
              Splits a given vector into a smaller vectors of the given size.
            </summary>
            <param name="vector">The vector to be splitted.</param>
            <param name="size">The size of the resulting vectors.</param>
            <returns>An array of vectors containing the subdivisions of the given vector.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Remove``1(``0[0:,0:],System.Int32[],System.Int32[])">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="startRow">Start row index</param>
            <param name="endRow">End row index</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32[],System.Int32[])">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32[],System.Int32[])">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32[])">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[],System.Int32[])">
            <summary>Returns a subvector extracted from the current vector.</summary>
            <param name="data">The vector to return the subvector from.</param>
            <param name="indexes">Array of indices.</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(System.Collections.Generic.List{``0},System.Int32[])">
            <summary>Returns a subvector extracted from the current vector.</summary>
            <param name="data">The vector to return the subvector from.</param>
            <param name="indexes">Array of indices.</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32[],System.Boolean)">
            <summary>Returns a subvector extracted from the current vector.</summary>
            <param name="data">The vector to return the subvector from.</param>
            <param name="indexes">Array of indices.</param>
            <param name="transpose">True to return a transposed matrix; false otherwise.</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[],System.Int32,System.Int32)">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The vector to return the subvector from.</param>
            <param name="startRow">Starting index.</param>
            <param name="endRow">End index.</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[],System.Int32)">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32,System.Int32,System.Int32[])">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="startRow">Starting row index</param>
            <param name="endRow">End row index</param>
            <param name="columnIndexes">Array of column indices</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32[],System.Int32,System.Int32)">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32[],System.Int32,System.Int32)">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices</param>
            <param name="j0">Start column index</param>
            <param name="j1">End column index</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32,System.Int32,System.Int32[])">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="i0">Starting row index</param>
            <param name="i1">End row index</param>
            <param name="columnIndexes">Array of column indices</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.GetColumn``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets a column vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.GetColumn``1(``0[][],System.Int32)">
            <summary>
              Gets a column vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.SetColumn``1(``0[0:,0:],System.Int32,``0[])">
            <summary>
              Stores a column vector into the given column position of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.GetRow``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets a row vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.SetRow``1(``0[0:,0:],System.Int32,``0[])">
            <summary>
              Stores a row vector into the given row position of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.RemoveColumn``1(``0[][],System.Int32)">
            <summary>
              Returns a new matrix without one of its columns.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.RemoveColumn``1(``0[0:,0:],System.Int32)">
            <summary>
              Returns a new matrix without one of its columns.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``1(``0[0:,0:],``0[])">
            <summary>
              Returns a new matrix with a given column vector inserted at the end of the original matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``1(``0[0:,0:],``0[],System.Int32)">
            <summary>
              Returns a new matrix with a given column vector inserted at a given index.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``1(``0[0:,0:],``0[])">
            <summary>
              Returns a new matrix with a given row vector inserted at the end of the original matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``1(``0[0:,0:],``0[],System.Int32)">
            <summary>
              Returns a new matrix with a given row vector inserted at a given index.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.RemoveRow``1(``0[0:,0:],System.Int32)">
            <summary>
              Returns a new matrix without one of its rows.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.RemoveAt``1(``0[],System.Int32)">
            <summary>
              Removes an element from a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[],System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
            <param name="firstOnly">
               Set to true to stop when the first element is
               found, set to false to get all elements.
            </param>
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[0:,0:],System.Func{``0,System.Boolean})">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[0:,0:],System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
            <param name="firstOnly">
               Set to true to stop when the first element is
               found, set to false to get all elements.
            </param>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(System.Nullable{``0}[],System.Int32@)">
            <summary>
              Gets the maximum non-null element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[],System.Int32@)">
            <summary>
              Gets the maximum element in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[])">
            <summary>
              Gets the maximum element in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[],System.Int32@)">
            <summary>
              Gets the minimum element in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[])">
            <summary>
              Gets the minimum element in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:])">
            <summary>
              Gets the maximum value of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:],System.Tuple{System.Int32,System.Int32}@)">
            <summary>
              Gets the maximum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:])">
            <summary>
              Gets the minimum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:],System.Tuple{System.Int32,System.Int32}@)">
            <summary>
              Gets the minimum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets the maximum values accross one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:],System.Int32,System.Int32[]@)">
            <summary>
              Gets the maximum values accross one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:],System.Int32,System.Int32[]@)">
            <summary>
              Gets the minimum values accross one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[][],System.Int32)">
            <summary>
              Gets the maximum values accross one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[][],System.Int32,System.Int32[]@)">
            <summary>
              Gets the maximum values accross one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[][],System.Int32)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[][],System.Int32,System.Int32[]@)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[])">
            <summary>
              Gets the range of the values in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Int32[])">
            <summary>
              Gets the range of the values in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[0:,0:])">
            <summary>
              Gets the range of the values accross the columns of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[][])">
            <summary>
              Gets the range of the values accross the columns of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Sort``2(``0[],``1[0:,0:],System.Collections.Generic.IComparer{``0})">
            <summary>
              Sorts the columns of a matrix by sorting keys.
            </summary>
            <param name="keys">The key value for each column.</param>
            <param name="values">The matrix to be sorted.</param>
            <param name="comparer">The comparer to use.</param>
        </member>
        <member name="M:Accord.Math.Matrix.Solve(System.Double[0:,0:],System.Double[0:,0:],System.Boolean)">
            <summary>
              Returns the solution matrix if the matrix is square or the least squares solution otherwise.
            </summary>
            
            <param name="matrix">The matrix for the linear problem.</param>
            <param name="rightSide">The right side <c>b</c>.</param>
            <param name="leastSquares">True to produce a solution even if the 
              <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
            
            <remarks>
              Please note that this does not check if the matrix is non-singular
              before attempting to solve. If a least squares solution is desired
              in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
              parameter when calling this function.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Solve(System.Double[0:,0:],System.Double[],System.Boolean)">
            <summary>
              Returns the solution matrix if the matrix is square or the least squares solution otherwise.
            </summary>
            
            <param name="matrix">The matrix for the linear problem.</param>
            <param name="rightSide">The right side <c>b</c>.</param>
            <param name="leastSquares">True to produce a solution even if the 
              <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
            
            <remarks>
              Please note that this does not check if the matrix is non-singular
              before attempting to solve. If a least squares solution is desired
              in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
              parameter when calling this function.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Inverse(System.Double[0:,0:])">
            <summary>
              Computes the inverse of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Inverse(System.Double[0:,0:],System.Boolean)">
            <summary>
              Computes the inverse of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.PseudoInverse(System.Double[0:,0:])">
            <summary>
              Computes the pseudo-inverse of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Int32[])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Double[])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sign(System.Double[])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Double[0:,0:])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Int32[0:,0:])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sqrt(System.Double[])">
            <summary>
              Elementwise Square root.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sqrt(System.Double[0:,0:])">
            <summary>
              Elementwise Square root.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Log(System.Double[0:,0:])">
            <summary>
              Elementwise Log operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Exp(System.Double[0:,0:])">
            <summary>
              Elementwise Exp operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Exp(System.Double[])">
            <summary>
              Elementwise Exp operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Log(System.Double[])">
            <summary>
              Elementwise Log operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwisePower(System.Double[0:,0:],System.Double)">
            <summary>
              Elementwise power operation.
            </summary>
            
            <param name="x">A matrix.</param>
            <param name="y">A power.</param>
            
            <returns>Returns x elevated to the power of y.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwisePower(System.Double[],System.Double)">
            <summary>
              Elementwise power operation.
            </summary>
            
            <param name="x">A matrix.</param>
            <param name="y">A power.</param>
            
            <returns>Returns x elevated to the power of y.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[],System.Double[])">
            <summary>
              Elementwise divide operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Elementwise divide operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Elementwise divide operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[0:,0:],System.Double[],System.Boolean)">
            <summary>
              Elementwise division.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[0:,0:],System.Double[],System.Int32,System.Boolean)">
            <summary>
              Elementwise division.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Int32[0:,0:],System.Int32[],System.Int32)">
            <summary>
              Elementwise division.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[],System.Double[])">
            <summary>
              Elementwise multiply operation.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[],System.Int32[])">
            <summary>
              Elementwise multiply operation.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Elementwise multiply operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Int32[],System.Int32[])">
            <summary>
              Elementwise multiply operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Int32[0:,0:],System.Int32[0:,0:])">
            <summary>
              Elementwise multiplication.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Elementwise multiplication.
            </summary>
            
            <param name="a">The left matrix a.</param>
            <param name="b">The right vector b.</param>
            <param name="dimension">
              If set to 0, b will be multiplied with every row vector in a. 
              If set to 1, b will be multiplied with every column vector.
            </param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[0:,0:],System.Double[],System.Double[0:,0:],System.Int32)">
            <summary>
              Elementwise multiplication.
            </summary>
            
            <param name="a">The left matrix a.</param>
            <param name="b">The right vector b.</param>
            <param name="r">The result vector r.</param>
            <param name="dimension">
              If set to 0, b will be multiplied with every row vector in a. 
              If set to 1, b will be multiplied with every column vector.
            </param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[][])">
            <summary>
              Converts a jagged-array into a multidimensional array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[][],System.Boolean)">
            <summary>
              Converts a jagged-array into a multidimensional array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[])">
            <summary>
              Converts an array into a multidimensional array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(``0[0:,0:])">
            <summary>
              Converts a multidimensional array into a jagged array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(``0[0:,0:],System.Boolean)">
            <summary>
              Converts a multidimensional array into a jagged array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Single[0:,0:])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a single-precision floating point multidimensional
              array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Single[])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a single-precision floating point multidimensional
              array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Int32[0:,0:])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a single-precision floating point multidimensional
              array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ToSingle(System.Double[0:,0:])">
            <summary>
              Converts a single-precision floating point multidimensional
              array into a double-precision floating point multidimensional
              array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.Double[])">
            <summary>
              Truncates a double vector to integer values.
            </summary>
            <param name="vector">The vector to be truncated.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.Double[0:,0:])">
            <summary>
              Truncates a double matrix to integer values.
            </summary>
            <param name="matrix">The matrix to be truncated.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Int32[])">
            <summary>
              Converts a integer vector into a double vector.
            </summary>
            <param name="vector">The vector to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convert``2(``0[],System.Converter{``0,``1})">
            <summary>
              Converts the values of a vector using the given converter expression.
            </summary>
            <typeparam name="TInput">The type of the input.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <param name="vector">The vector to be converted.</param>
            <param name="converter">The converter function.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix(System.Data.DataTable)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix(System.Data.DataTable,System.String[]@)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Double[0:,0:])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Double[0:,0:],System.String[])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable,System.String[]@)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataColumn)">
            <summary>
              Converts a DataColumn to a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToIntArray(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a int[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32Array(System.Data.DataColumn)">
            <summary>
              Converts a DataColumn to a int[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[0:,0:],System.Double[0:,0:],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Single[0:,0:],System.Single[0:,0:],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[][],System.Double[][],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Single[][],System.Single[][],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[],System.Double[],System.Double)">
            <summary>
              Compares two vectors for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Single[],System.Single[],System.Double)">
            <summary>
              Compares two vectors for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[],System.Double)">
            <summary>
              Compares each member of a vector for equality with a scalar value x.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[0:,0:],System.Double)">
            <summary>
              Compares each member of a matrix for equality with a scalar value x.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual``1(``0[][],``0[][])">
            <summary>
              Compares two matrices for equality.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual``1(``0[0:,0:],``0[0:,0:])">
            <summary>Compares two matrices for equality.</summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual``1(``0[],``0[])">
            <summary>Compares two vectors for equality.</summary>
        </member>
        <member name="M:Accord.Math.Matrix.Equals(System.Object)">
            <summary>
              This method should not be called. Use Matrix.IsEqual instead.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasNaN(System.Double[0:,0:])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a value that is not a number (NaN).
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a value that is not a number, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasNaN(System.Double[])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a value that is not a number (NaN).
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a value that is not a number, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[0:,0:])">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
            <returns>The transpose of the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[][])">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
            <returns>The transpose of the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[0:,0:],System.Boolean)">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
            <param name="inPlace">True to store the transpose over the same input
              <paramref name="matrix"/>, false otherwise. Default is false.</param>
            <returns>The transpose of the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[][],System.Boolean)">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
            <param name="inPlace">True to store the transpose over the same input
              <paramref name="matrix"/>, false otherwise. Default is false.</param>
            <returns>The transpose of the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[])">
            <summary>
              Gets the transpose of a row vector.
            </summary>
            <param name="rowVector">A row vector.</param>
            <returns>The transpose of the given vector.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsSquare``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is square.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsSymmetric``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is symmetric.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsUpperTriangular``1(``0[][])">
            <summary>
              Returns true if a matrix is upper triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsLowerTriangular``1(``0[][])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsUpperTriangular``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is upper triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsLowerTriangular``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsDiagonal``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsDiagonal``1(``0[][])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsSymmetric``1(``0[][])">
            <summary>
              Returns true if a matrix is symmetric.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Double[0:,0:])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Int32[0:,0:])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Single[0:,0:])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Single[][])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(``0[][])">
            <summary>
              Gets the diagonal vector from a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
            <returns>The diagonal vector from the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(``0[0:,0:])">
            <summary>
              Gets the diagonal vector from a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
            <returns>The diagonal vector from the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Determinant(System.Double[0:,0:])">
            <summary>
              Gets the determinant of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Determinant(System.Double[0:,0:],System.Boolean)">
            <summary>
              Gets the determinant of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Rank(System.Double[0:,0:])">
            <summary>
              Gets the determinant of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Rank(System.Single[0:,0:])">
            <summary>
              Gets the determinant of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsSingular(System.Double[0:,0:])">
            <summary>
               Gets whether a matrix is singular.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsPositiveDefinite(System.Double[0:,0:])">
            <summary>
               Gets whether a matrix is positive definite.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsPositiveDefinite(System.Double[][])">
            <summary>
               Gets whether a matrix is positive definite.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[0:,0:])">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[][])">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[][],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Int32[0:,0:])">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Int32[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated. Default is 0.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[])">
            <summary>
              Gets the sum of all elements in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Single[])">
            <summary>
              Gets the sum of all elements in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Int32[])">
            <summary>
              Gets the sum of all elements in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.CumulativeSum(System.Double[])">
            <summary>Calculates a vector cumulative sum.</summary>
        </member>
        <member name="M:Accord.Math.Matrix.CumulativeSum(System.Double[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the cumulative sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Product(System.Double[])">
            <summary>
              Gets the product of all elements in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Product(System.Int32[])">
            <summary>
              Gets the product of all elements in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[],System.Func{``0,``0})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[],System.Func{``0,System.Int32,``0})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[0:,0:],System.Func{``0,``0})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[0:,0:],System.Func{``0,System.Int32,System.Int32,``0})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Apply``2(``0[],System.Func{``0,``1})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyWithIndex``2(``0[],System.Func{``0,System.Int32,``1})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Apply``2(``0[0:,0:],System.Func{``0,``1})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyWithIndex``2(``0[0:,0:],System.Func{``0,System.Int32,System.Int32,``1})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Round(System.Double[0:,0:],System.Int32)">
            <summary>
              Rounds a double-precision floating-point matrix to a specified number of fractional digits.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Floor(System.Double[0:,0:])">
            <summary>
              Returns the largest integer less than or equal than to the specified 
              double-precision floating-point number for each element of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Ceiling(System.Double[0:,0:])">
            <summary>
              Returns the largest integer greater than or equal than to the specified 
              double-precision floating-point number for each element of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Round(System.Double[],System.Int32)">
            <summary>
              Rounds a double-precision floating-point number array to a specified number of fractional digits.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Floor(System.Double[])">
            <summary>
              Returns the largest integer less than or equal than to the specified 
              double-precision floating-point number for each element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Ceiling(System.Double[])">
            <summary>
              Returns the largest integer greater than or equal than to the specified 
              double-precision floating-point number for each element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[],System.Int32,System.Int32)">
            <summary>
              Transforms a vector into a matrix of given dimensions.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[0:,0:],System.Int32)">
            <summary>
              Transforms a matrix into a single vector.
            </summary>
            <param name="matrix">A matrix.</param>
            <param name="dimension">The direction to perform copying. Pass
            0 to perform a row-wise copy. Pass 1 to perform a column-wise
            copy.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[][],System.Int32)">
            <summary>
              Transforms a jagged array matrix into a single vector.
            </summary>
            <param name="array">A jagged array.</param>
            <param name="dimension">The direction to perform copying. Pass
            0 to perform a row-wise copy. Pass 1 to perform a column-wise
            copy.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convolve(System.Double[],System.Double[])">
            <summary>
              Convolves an array with the given kernel.
            </summary>
            <param name="a">A floating number array.</param>
            <param name="kernel">A convolution kernel.</param>
        </member>
        <member name="M:Accord.Math.Matrix.Convolve(System.Double[],System.Double[],System.Boolean)">
            <summary>
            Convolves an array with the given kernel.
            </summary>
            <param name="a">A floating number array.</param>
            <param name="kernel">A convolution kernel.</param>
            <param name="trim">
              If <c>true</c> the resulting array will be trimmed to
              have the same length as the input array. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Matrix.MemberwiseClone``1(``0[][])">
            <summary>
              Creates a memberwise copy of a jagged matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Single[][])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[][],System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Single[][],System.Single[][])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and
              transpose of <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
               
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Single[0:,0:],System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and
              transpose of <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
               
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and vector <c>b</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right column vector <c>b</c>.</param>
            <returns>The product <c>A'*b</c> of the given matrices <c>A</c> and vector <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[],System.Double[])">
            <summary>
              Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right column vector <c>b</c>.</param>
            <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
              of the given matrix <c>A</c> and vector <c>b</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Single[0:,0:],System.Single[])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Single[0:,0:],System.Single[],System.Single[0:,0:])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.DivideByDiagonal(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of inverse right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.DivideByDiagonal(System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of inverse right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[],System.Double[0:,0:])">
            <summary>
              Multiplies a row vector <c>v</c> and a matrix <c>A</c>,
              giving the product <c>v'*A</c>.
            </summary>
            
            <param name="rowVector">The row vector <c>v</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>v'*A</c>of the multiplication of the
              given row vector <c>v</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[],System.Single[0:,0:])">
            <summary>
              Multiplies a row vector <c>v</c> and a matrix <c>A</c>,
              giving the product <c>v'*A</c>.
            </summary>
            
            <param name="rowVector">The row vector <c>v</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>v'*A</c>of the multiplication of the
              given row vector <c>v</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double[])">
            <summary>
              Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
              giving the product <c>A*v</c>
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="columnVector">The column vector <c>v</c>.</param>
            <returns>The product <c>A*v</c> of the multiplication of the
              given matrix <c>A</c> and column vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[][],System.Double[])">
            <summary>
              Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
              giving the product <c>A*v</c>
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="columnVector">The column vector <c>v</c>.</param>
            <returns>The product <c>A*v</c> of the multiplication of the
              given matrix <c>A</c> and column vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single[])">
            <summary>
              Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
              giving the product <c>A*v</c>
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="columnVector">The column vector <c>v</c>.</param>
            <returns>The product <c>A*v</c> of the multiplication of the
              given matrix <c>A</c> and column vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double)">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <returns>The product <c>A*x</c> of the multiplication of the
              given matrix <c>A</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double,System.Double[0:,0:])">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R=A*x</c>
              of the multiplication of the given matrix <c>A</c> and scalar <c>x</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[],System.Double)">
            <summary>
              Multiplies a vector <c>v</c> by a scalar <c>x</c>.
            </summary>
            <param name="vector">The vector <c>v</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <returns>The product <c>v*x</c> of the multiplication of the 
              given vector <c>v</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double,System.Double[0:,0:])">
            <summary>
              Multiplies a scalar <c>x</c> by a matrix <c>A</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>x*A</c> of the multiplication of the
              given scalar <c>x</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double,System.Double[])">
            <summary>
              Multiplies a scalar <c>x</c> by a vector <c>v</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="vector">The vector <c>v</c>.</param>
            <returns>The product <c>x*v</c> of the multiplication of the 
              given scalar <c>x</c> and vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Int32,System.Double[])">
            <summary>
              Multiplies a scalar <c>x</c> by a vector <c>v</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="vector">The vector <c>v</c>.</param>
            <returns>The product <c>x*v</c> of the multiplication of the 
              given scalar <c>x</c> and vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double,System.Double[],System.Boolean)">
            <summary>
              Divides a scalar by a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Int32,System.Double[],System.Boolean)">
            <summary>
              Divides a scalar by a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double[],System.Double,System.Boolean)">
            <summary>
              Divides a vector by a scalar.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Int32[],System.Double)">
            <summary>
              Divides a vector by a scalar.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Single[],System.Single)">
            <summary>
              Divides a vector by a scalar.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double,System.Double[])">
            <summary>
              Elementwise divides a scalar by a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given scalar <c>a</c> and vector <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Divides two matrices by multiplying A by the inverse of B.
            </summary>
            
            <param name="a">The first matrix.</param>
            <param name="b">The second matrix (which will be inverted).</param>
            
            <returns>The result from the division <c>AB^-1</c> of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double[0:,0:],System.Double,System.Boolean)">
            <summary>
              Divides a matrix by a scalar.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
            <returns>The division quotient of the given matrix and scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.UInt32[0:,0:],System.Single)">
            <summary>
              Divides a matrix by a scalar.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given matrix and scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double,System.Double[0:,0:])">
            <summary>
              Elementwise divides a scalar by a matrix.
            </summary>
            
            <param name="x">A scalar.</param>
            <param name="matrix">A matrix.</param>
            
            <returns>The elementwise division of the given scalar and matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.InnerProduct(System.Double[],System.Double[])">
            <summary>
              Gets the inner product (scalar product) between two vectors (a'*b).
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The inner product of the multiplication of the vectors.</returns>
            
            <remarks>
             <para>
               In mathematics, the dot product is an algebraic operation that takes two
               equal-length sequences of numbers (usually coordinate vectors) and returns
               a single number obtained by multiplying corresponding entries and adding up
               those products. The name is derived from the dot that is often used to designate
               this operation; the alternative name scalar product emphasizes the scalar
               (rather than vector) nature of the result.</para>
             <para>
               The principal use of this product is the inner product in a Euclidean vector space:
               when two vectors are expressed on an orthonormal basis, the dot product of their 
               coordinate vectors gives their inner product.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.InnerProduct(System.Single[],System.Single[])">
            <summary>
              Gets the inner product (scalar product) between two vectors (a'*b).
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The inner product of the multiplication of the vectors.</returns>
            
            <remarks>
             <para>
               In mathematics, the dot product is an algebraic operation that takes two
               equal-length sequences of numbers (usually coordinate vectors) and returns
               a single number obtained by multiplying corresponding entries and adding up
               those products. The name is derived from the dot that is often used to designate
               this operation; the alternative name scalar product emphasizes the scalar
               (rather than vector) nature of the result.</para>
             <para>
               The principal use of this product is the inner product in a Euclidean vector space:
               when two vectors are expressed on an orthonormal basis, the dot product of their 
               coordinate vectors gives their inner product.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.OuterProduct(System.Double[],System.Double[])">
            <summary>
              Gets the outer product (matrix product) between two vectors (a*bT).
            </summary>
            
            <remarks>
              In linear algebra, the outer product typically refers to the tensor
              product of two vectors. The result of applying the outer product to
              a pair of vectors is a matrix. The name contrasts with the inner product,
              which takes as input a pair of vectors and produces a scalar.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.VectorProduct(System.Double[],System.Double[])">
            <summary>
              Vectorial product.
            </summary>
            
            <remarks>
              The cross product, vector product or Gibbs vector product is a binary operation
              on two vectors in three-dimensional space. It has a vector result, a vector which
              is always perpendicular to both of the vectors being multiplied and the plane
              containing them. It has many applications in mathematics, engineering and physics.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.VectorProduct(System.Single[],System.Single[])">
            <summary>
              Vectorial product.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.CartesianProduct``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
              Computes the cartesian product of many sets.
            </summary>
            
            <remarks>
              References:
              - http://blogs.msdn.com/b/ericlippert/archive/2010/06/28/computing-a-cartesian-product-with-linq.aspx 
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.CartesianProduct``1(``0[][])">
            <summary>
              Computes the cartesian product of many sets.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.CartesianProduct``1(``0[],``0[])">
            <summary>
              Computes the cartesian product of two sets.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.KroneckerProduct(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the Kronecker product between two matrices.
            </summary>
            
            <param name="a">The left matrix a.</param>
            <param name="b">The right matrix b.</param>
            
            <returns>The Kronecker product of the two matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.KroneckerProduct(System.Double[],System.Double[])">
            <summary>
              Computes the Kronecker product between two vectors.
            </summary>
            
            <param name="a">The left vector a.</param>
            <param name="b">The right vector b.</param>
            
            <returns>The Kronecker product of the two vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Adds two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            
            <returns>The sum of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[][],System.Double[][])">
            <summary>
              Adds two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            
            <returns>The sum of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Adds a vector to a column or row of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="vector">A vector.</param>
            <param name="dimension">
              Pass 0 if the vector should be added row-wise, 
              or 1 if the vector should be added column-wise.
            </param>
            
        </member>
        <member name="M:Accord.Math.Matrix.AddToDiagonal(System.Double[0:,0:],System.Double,System.Boolean)">
            <summary>
              Adds a scalar to the diagonal of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="scalar">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Adds a vector to a column or row of a matrix.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A vector.</param>
            <param name="dimension">The dimension to add the vector to.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[],System.Double[])">
            <summary>
              Adds two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The addition of the given vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[],System.Double)">
            <summary>
              Adds two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The addition of the given vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[0:,0:],System.Double[0:,0:],System.Boolean)">
            <summary>
              Subtracts two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
            <returns>The subtraction of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[][],System.Double[][])">
            <summary>
              Subtracts two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            
            <returns>The subtraction of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[0:,0:],System.Double)">
            <summary>
              Subtracts a scalar from each element of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double,System.Double[0:,0:])">
            <summary>
              Elementwise subtracts an element of a matrix from a scalar.
            </summary>
            
            <param name="x">A scalar.</param>
            <param name="matrix">A matrix.</param>
            
            <returns>The elementwise subtraction of scalar a and matrix b.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[],System.Double[],System.Boolean)">
            <summary>
              Subtracts two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of vector b from vector a.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[],System.Double,System.Boolean)">
            <summary>
              Subtracts a scalar from a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of given scalar from all elements in the given vector.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Int32[],System.Int32,System.Boolean)">
            <summary>
              Subtracts a scalar from a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of given scalar from all elements in the given vector.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double,System.Double[])">
            <summary>
              Subtracts a scalar from a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The subtraction of the given vector elements from the given scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Power(System.Double[0:,0:],System.Int32)">
            <summary>
              Multiplies a matrix by itself <c>n</c> times.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Formats.MatrixFormatProviderBase">
            <summary>
              Base class for IMatrixFormatProvider implementors.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Formats.IMatrixFormatProvider">
            <summary>
              Common interface for Matrix format providers.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.FormatMatrixStart">
            <summary>A string denoting the start of the matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.FormatMatrixEnd">
            <summary>A string denoting the end of the matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.FormatRowStart">
            <summary>A string denoting the start of a matrix row to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.FormatRowEnd">
            <summary>A string denoting the end of a matrix row to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.FormatColStart">
            <summary>A string denoting the start of a matrix column to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.FormatColEnd">
            <summary>A string denoting the end of a matrix column to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.FormatRowDelimiter">
            <summary>A string containing the row delimiter for a matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.FormatColDelimiter">
            <summary>A string containing the column delimiter for a matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.ParseMatrixStart">
            <summary>A string denoting the start of the matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.ParseMatrixEnd">
            <summary>A string denoting the end of the matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.ParseRowStart">
            <summary>A string denoting the start of a matrix row to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.ParseRowEnd">
            <summary>A string denoting the end of a matrix row to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.ParseColStart">
            <summary>A string denoting the start of a matrix column to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.ParseColEnd">
            <summary>A string denoting the end of a matrix column to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.ParseRowDelimiter">
            <summary>A string containing the row delimiter for a matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.ParseColDelimiter">
            <summary>A string containing the column delimiter for a matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.Formats.IMatrixFormatProvider.CultureInfo">
            <summary>
              Gets the culture specific formatting information
              to be used during parsing or formatting.
            </summary>
        </member>
        <member name="M:Accord.Math.Formats.MatrixFormatProviderBase.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Math.Formats.MatrixFormatProviderBase"/> class.
            </summary>
            <param name="culture">The culture.</param>
        </member>
        <member name="M:Accord.Math.Formats.MatrixFormatProviderBase.GetFormat(System.Type)">
            <summary>
              Returns an object that provides formatting services for the specified
              type. Currently, only <see cref="T:Accord.Math.Formats.IMatrixFormatProvider"/> is supported.
            </summary>
            <param name="formatType">
              An object that specifies the type of format
              object to return. </param>
            <returns>
              An instance of the object specified by formatType, if the
              <see cref="T:System.IFormatProvider">IFormatProvider</see> implementation
              can supply that type of object; otherwise, null.</returns>
              
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.FormatMatrixStart">
            <summary>
            A string denoting the start of the matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.FormatMatrixEnd">
            <summary>
            A string denoting the end of the matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.FormatRowStart">
            <summary>
            A string denoting the start of a matrix row to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.FormatRowEnd">
            <summary>
            A string denoting the end of a matrix row to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.FormatColStart">
            <summary>
            A string denoting the start of a matrix column to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.FormatColEnd">
            <summary>
            A string denoting the end of a matrix column to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.FormatRowDelimiter">
            <summary>
            A string containing the row delimiter for a matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.FormatColDelimiter">
            <summary>
            A string containing the column delimiter for a matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.ParseMatrixStart">
            <summary>
            A string denoting the start of the matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.ParseMatrixEnd">
            <summary>
            A string denoting the end of the matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.ParseRowStart">
            <summary>
            A string denoting the start of a matrix row to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.ParseRowEnd">
            <summary>
            A string denoting the end of a matrix row to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.ParseColStart">
            <summary>
            A string denoting the start of a matrix column to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.ParseColEnd">
            <summary>
            A string denoting the end of a matrix column to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.ParseRowDelimiter">
            <summary>
            A string containing the row delimiter for a matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.ParseColDelimiter">
            <summary>
            A string containing the column delimiter for a matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.MatrixFormatProviderBase.CultureInfo">
            <summary>
            Gets the culture specific formatting information
            to be used during parsing or formatting.
            </summary>
        </member>
        <member name="T:Accord.Math.Wavelets.IWavelet">
            <summary>
              Common interface for wavelets algorithms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Forward(System.Double[])">
            <summary>
              1-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Forward(System.Double[0:,0:])">
            <summary>
              2-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Backward(System.Double[])">
            <summary>
              1-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Backward(System.Double[0:,0:])">
            <summary>
              2-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="T:Accord.Math.HilbertTransform">
            <summary>
              Discrete Hilbert Transformation.
            </summary>
            
            <remarks>
            <para>
              The discrete Hilbert transform is a transformation operating on the time
              domain. It performs a 90 degree phase shift, shifting positive frequencies
              by +90 degrees and negative frequencies by -90 degrees. It is useful to
              create analytic representation of signals. </para>
              
            <para>
              The Hilbert transform can be implemented efficiently by using the Fast
              Fourier Transform. After transforming a signal from the time-domain to
              the frequency domain, one can zero its negative frequency components and
              revert the signal back to obtain the phase shifting.</para>
              
             <para>
               By applying the Hilbert transform to a signal twice, the negative of
               the original signal is recovered.</para>
            
              <para>
                References:
                <list type="bullet">
                  <item><description>
                   Marple, S.L., "Computing the discrete-time analytic signal via FFT," IEEE 
                   Transactions on Signal Processing, Vol. 47, No.9 (September 1999). Available on:
                   http://classes.engr.oregonstate.edu/eecs/winter2009/ece464/AnalyticSignal_Sept1999_SPTrans.pdf </description></item>
                  <item><description>
                   J. F. Culling, Online, cross-indexed dictionary of DSP terms. Available on:
                   http://www.cardiff.ac.uk/psych/home2/CullingJ/frames_dict.html </description></item>
                </list>
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.HilbertTransform.FHT(System.Double[],AForge.Math.FourierTransform.Direction)">
            <summary>
              Performs the transformation over a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.HilbertTransform.FHT(AForge.Math.Complex[],AForge.Math.FourierTransform.Direction)">
            <summary>
              Performs the transformation over a complex[] array.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.NonnegativeMatrixFactorization">
            <summary>
              Nonnegative Matrix Factorization.
            </summary>
            
            <remarks>
            <para>
              Non-negative matrix factorization (NMF) is a group of algorithms in multivariate
              analysis and linear algebra where a matrix <c>X</c> is factorized into (usually)
              two matrices, <c>W</c> and <c>H</c>. The non-negative factorization enforces the
              constraint that the factors <c>W</c> and <c>H</c> must be non-negative, i.e., all
              elements must be equal to or greater than zero. The factorization is not unique.</para>
              
              <para>
                References:
                <list type="bullet">
                  <item><description>
                    <a href="http://en.wikipedia.org/wiki/Non-negative_matrix_factorization">
                    http://en.wikipedia.org/wiki/Non-negative_matrix_factorization </a>
                  </description></item>
                  <item><description>
                    Lee, D., Seung, H., 1999. Learning the Parts of Objects by Non-Negative
                    Matrix Factorization. Nature 401, 788–791. </description></item>
                  <item><description>
                    Michael W. Berry, et al. (June 2006). Algorithms and Applications for 
                    Approximate Nonnegative Matrix Factorization. </description></item>
                </list>
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.NonnegativeMatrixFactorization.#ctor(System.Double[0:,0:],System.Int32)">
            <summary>
              Initializes a new instance of the NMF algorithm
            </summary>
            
            <param name="value">The input data matrix (must be positive).</param>
            <param name="r">The reduced dimension.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.NonnegativeMatrixFactorization.#ctor(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the NMF algorithm
            </summary>
            
            <param name="value">The input data matrix (must be positive).</param>
            <param name="r">The reduced dimension.</param>
            <param name="maxiter">The number of iterations to perform.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.NonnegativeMatrixFactorization.compute(System.Int32)">
            <summary>
               Performs NMF using the multiplicative method
            </summary>
            
            <param name="maxiter">The maximum number of iterations</param>
            
            <remarks>
              At the end of the computation H contains the projected data
              and W contains the weights. The multiplicative method is the
              simplest factorization method.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Decompositions.NonnegativeMatrixFactorization.LeftNonnegativeFactors">
            <summary>
              Gets the nonnegative factor matrix W.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.NonnegativeMatrixFactorization.RightNonnegativeFactors">
            <summary>
              Gets the nonnegative factor matrix H.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedCholeskyDecompositionD">
            <summary>
                   Cholesky Decomposition of a symmetric, positive definite matrix.
               </summary>
            <remarks>
              <para>
                   For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                   lower triangular matrix <c>L</c> so that <c>A = L * L'</c>. The presented algorithm
                   only checks the upper triangular part of the matrix given as parameter and assumes
                   it is symmetric. If the matrix is not positive definite, the constructor returns a 
                   partial decomposition and sets two internal variables that can be queried using the
                   <see cref="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.#ctor(System.Decimal[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new Cholesky Decomposition.
            </summary>
            
            <param name="value">
              The symmetric matrix, given in upper triangular form, to be decomposed.</param>
            <param name="robust">
              True to perform a square-root free LDLt decomposition, false otherwise.</param>
            <param name="inPlace">
              True to perform the decomposition in place, storing the factorization in the
              lower triangular part of the given matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[][],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[])">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.InverseDiagonal(System.Boolean)">
            <summary>
              Computes the diagonal of the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.InverseDiagonal(System.Decimal[],System.Boolean)">
             <summary>
               Computes the diagonal of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the proccess. Pass false otherwise.</param>
             <param name="result">The array to hold the result of the 
                computation. Should be of same length as the the diagonal
                of the original matrix.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.InverseTrace(System.Boolean)">
             <summary>
               Computes the trace of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the proccess. Pass false otherwise.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.FromLeftTriangularMatrix(System.Decimal[][])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.PositiveDefinite">
            <summary>
              Returns <see langword="true"/> if the matrix is positive definite.
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.IsNotDefined">
            <summary>
              Gets a value indicating whether the LDLt factorization
              has been computed successfully or if it is undefined.
            </summary>
            
            <value>
                <c>true</c> if the factorization is not defined; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.LeftTriangularFactor">
            <summary>
              Returns the left (lower) triangular factor
              <c>L</c> so that <c>A = L * D * L'</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.DiagonalMatrix">
            <summary>
              Returns the block diagonal matrix of diagonal
              elements in a LDLt decomposition.
            </summary>        
              
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Diagonal">
            <summary>
              Returns the one-dimensional array of diagonal 
              elements in a LDLt decomposition.
            </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Determinant">
            <summary>
              Returns the determinant of
              the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.LogDeterminant">
            <summary>
              If the matrix is positive-definite, returns the
              log-determinant of the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Nonsingular">
            <summary>
              Gets a value indicating whether the decomposed
              matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Constants">
            <summary>
              Common mathematical constants.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  http://www.johndcook.com/cpp_expm1.html </description></item>
              </list>
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.EulerGamma">
            <summary>Euler-Mascheroni constant.</summary>
        </member>
        <member name="F:Accord.Math.Constants.DoubleEpsilon">
            <summary>Double-precision machine roundoff error.</summary>
            <remarks>This value is actually different from Double.Epsilon.</remarks>
        </member>
        <member name="F:Accord.Math.Constants.SingleEpsilon">
            <summary>Single-precision machine roundoff error.</summary>
            <remarks>This value is actually different from Single.Epsilon.</remarks>
        </member>
        <member name="F:Accord.Math.Constants.DoubleSmall">
            <summary>Double-precision small value.</summary>
        </member>
        <member name="F:Accord.Math.Constants.SingleSmall">
            <summary>Single-precision small value.</summary>
        </member>
        <member name="F:Accord.Math.Constants.LogMax">
            <summary>Maximum log on the machine.</summary>
        </member>
        <member name="F:Accord.Math.Constants.LogMin">
            <summary>Minimum log on the machine.</summary>
        </member>
        <member name="F:Accord.Math.Constants.LogPI">
            <summary>Log of number pi: log(pi).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Log2">
            <summary>Log of two: log(2).</summary>
        </member>
        <member name="F:Accord.Math.Constants.LogSqrt2PI">
            <summary>Log of square root of twice number pi: log(sqrt(2*pi).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Log2PI">
            <summary>Log of twice number pi: log(2*pi).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Sqrt2PI">
            <summary>Square root of twice number pi: sqrt(2*pi).</summary>
        </member>
        <member name="F:Accord.Math.Constants.SqrtHalfPI">
            <summary>Square root of half number pi: sqrt(pi/2).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Sqrt2">
            <summary>Square root of 2: sqrt(2).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Sqrt2H">
            <summary>Half square root of 2: sqrt(2)/2.</summary>
        </member>
        <member name="T:Accord.Math.Formats.CSharpMatrixFormatProvider">
            <summary>
              Gets the matrix representation used in C# multi-dimensional arrays.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Formats.CSharpMatrixFormatProvider.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Math.Formats.CSharpMatrixFormatProvider"/> class.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.CSharpMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Formats.CSharpMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.QuadraticObjectiveFunction">
            <summary>
              Quadractic objective function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.IObjectiveFunction">
            <summary>
              Common interface for specifying objective functions.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.Variables">
            <summary>
              Gets input variable's labels for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.Indices">
            <summary>
              Gets the index of each input variable in the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.NumberOfVariables">
            <summary>
              Gets the number of input variables for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.Function">
            <summary>
              Gets the objective function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.#ctor(System.String)">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="f">A <see cref="T:System.String"/> containing the function in the form similar to "ax²+b".</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.#ctor(System.Linq.Expressions.Expression{System.Func{System.Double}})">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="f">A <see cref="T:System.Linq.Expressions.Expression`1"/> containing the function in the form of a lambda expression.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.GetQuadraticTermsMatrix">
            <summary>
              Gets the Hessian matrix of quadratic terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.GetLinearTermsVector">
            <summary>
              Gets the vector of linear terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.Variables">
            <summary>
              Gets input variable's labels for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.Indices">
            <summary>
              Gets the index of each input variable in the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.NumberOfVariables">
            <summary>
              Gets the number of input variables for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.Function">
            <summary>
              Gets the objective function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.ConjugateGradientMethod">
            <summary>
              Conjugate gradient direction update formula.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientMethod.FletcherReeves">
            <summary>
              Fletcher-Reeves formula.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientMethod.PolakRibiere">
            <summary>
              Polak-Ribière formula.
            </summary>
            
            <remarks>
              The Polak-Ribière is known to perform better for non-quadratic functions.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientMethod.PositivePolakRibiere">
            <summary>
              Polak-Ribière formula.
            </summary>
            
            <remarks>
              The Polak-Ribière is known to perform better for non-quadratic functions.
              The positive version B=max(0,Bpr) provides a direction reset automatically.
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Optimization.ConjugateGradient">
            <summary>
              Conjugate Gradient (CG) optimization method.
            </summary>
            
            <remarks>
            <para>
              In mathematics, the conjugate gradient method is an algorithm for the numerical solution of
              particular systems of linear equations, namely those whose matrix is symmetric and positive-
              definite. The conjugate gradient method is an iterative method, so it can be applied to sparse
              systems that are too large to be handled by direct methods. Such systems often arise when
              numerically solving partial differential equations. The nonlinear conjugate gradient method 
              generalizes the conjugate gradient method to nonlinear optimization (Wikipedia, 2011).</para>
            <para>
              T</para>
            <para>
              The framework implementation of this method is based on the original FORTRAN source code
              by Jorge Nocedal (see references below). The original FORTRAN source code of CG+ (for large
              scale unconstrained problems) is available at http://users.eecs.northwestern.edu/~nocedal/CG+.html
              and had been made freely available for educational or commercial use. The original authors
              expect that all publications describing work using this software quote the (Gilbert and Nocedal, 1992)
              reference given below.</para>
            
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://users.eecs.northwestern.edu/~nocedal/CG+.html">
                   J. C. Gilbert and J. Nocedal. Global Convergence Properties of Conjugate Gradient
                   Methods for Optimization, (1992) SIAM J. on Optimization, 2, 1.</a></description></item>
                <item><description>
                   Wikipedia contributors, "Nonlinear conjugate gradient method," Wikipedia, The Free 
                   Encyclopedia, http://en.wikipedia.org/w/index.php?title=Nonlinear_conjugate_gradient_method
                   (accessed December 22, 2011).</description></item>
                <item><description>
                   Wikipedia contributors, "Conjugate gradient method," Wikipedia, The Free Encyclopedia,
                   http://en.wikipedia.org/w/index.php?title=Conjugate_gradient_method 
                   (accessed December 22, 2011).</description></item>
               </list></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.#ctor(System.Int32)">
            <summary>
              Creates a new instance of the CG optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new instance of the CG optimization algorithm.
            </summary>
            
            <param name="parameters">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.Minimize">
            <summary>
              Optimizes the defined function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.Minimize(System.Double[])">
            <summary>
              Optimizes the defined function.
            </summary>
            
            <param name="values">The initial guess values for the parameters.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Tolerance">
            <summary>
              Gets or sets the relative difference threshold
              to be used as stopping criteria between two
              iterations. Default is 0 (iterate until convergence). 
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.MaxIterations">
            <summary>
              Gets or sets the maximum number of iterations
              to be performed during optimization. Default
              is 0 (iterate until convergence).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Method">
            <summary>
              Gets or sets the conjugate gradient update 
              method to be used during optimization.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Iterations">
            <summary>
              Gets the number of iterations performed 
              in the last call to <see cref="M:Accord.Math.Optimization.ConjugateGradient.Minimize"/>.
            </summary>
            
            <value>
              The number of iterations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Evaluations">
            <summary>
              Gets the number of function evaluations performed
              in the last call to <see cref="M:Accord.Math.Optimization.ConjugateGradient.Minimize"/>.
            </summary>
            
            <value>
              The number of evaluations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Searches">
            <summary>
              Gets the number of linear searches performed
              in the last call to <see cref="M:Accord.Math.Optimization.ConjugateGradient.Minimize"/>.
            </summary>
            
        </member>
        <member name="E:Accord.Math.Optimization.ConjugateGradient.Progress">
            <summary>
              Occurs when progress is made during the optimization.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Function">
            <summary>
              Gets or sets the function to be optimized.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Gradient">
            <summary>
              Gets or sets a function returning the gradient
              vector of the function to be optimized for a
              given value of its free parameters.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Parameters">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Solution">
            <summary>
              Gets the solution found, the values of the 
              parameters which optimizes the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Value">
            <summary>
              Gets the output of the function at the current solution.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.SingularValueDecompositionF">
            <summary>
              Singular Value Decomposition for a rectangular matrix.
            </summary>
            <remarks>
             <para>
                 For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the singular value decomposition
              is an m-by-n orthogonal matrix <c>U</c>, an n-by-n diagonal matrix <c>S</c>, and
              an n-by-n orthogonal matrix <c>V</c> so that <c>A = U * S * V'</c>.
              The singular values, <c>sigma[k] = S[k,k]</c>, are ordered so that
              <c>sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1]</c>.</para>
             <para>
              The singular value decomposition always exists, so the constructor will
              never fail. The matrix condition number and the effective numerical
              rank can be computed from this decomposition.</para>
             <para>
              WARNING! Please be aware that if A has less rows than columns, it is better
              to compute the decomposition on the transpose of A and then swap the left
              and right eigenvectors. If the routine is computed on A directly, the diagonal
              of singular values may contain one or more zeros. The identity A = U * S * V'
              may still hold, however. To overcome this problem, pass true to the
              <see cref="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean,System.Boolean)">autoTranspose</see> argument of the class constructor.</para>
             <para>
              This routine computes the economy decomposition of A.</para> 
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Decompositions.ISolverMatrixDecomposition`1">
            <summary>
              Common interface for matrix decompositions which
              can be used to solve linear systems of equations.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverMatrixDecomposition`1.Solve(`0[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverMatrixDecomposition`1.Solve(`0[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverMatrixDecomposition`1.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>Constructs a new singular value decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new singular value decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean,System.Boolean)">
            <summary>Constructs a new singular value decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Constructs a new singular value decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Solve(System.Single[0:,0:])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.SolveForDiagonal(System.Single[])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a linear equation system of the form Ax = b.
            </summary>
            <param name="value">The b from the equation Ax = b.</param>
            <returns>The x from equation Ax = b.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Inverse">
             <summary>
               Computes the (pseudo-)inverse of the matrix given to the Singular value decomposition.
             </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Clone">
             <summary>
               Creates a new object that is a copy of the current instance.
             </summary>
             <returns>
               A new object that is a copy of this instance.
             </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Condition">
             <summary>
               Returns the condition number <c>max(S) / min(S)</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Threshold">
             <summary>
               Returns the singularity threshold.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.TwoNorm">
             <summary>
               Returns the Two norm.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Rank">
            <summary>Returns the effective numerical matrix rank.</summary>
            <value>Number of non-negligible singular values.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Diagonal">
            <summary>Returns the one-dimensional array of singular values.</summary>        
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.DiagonalMatrix">
            <summary>Returns the block diagonal matrix of singular values.</summary>        
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.RightSingularVectors">
            <summary>Returns the V matrix of Singular Vectors.</summary>        
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.LeftSingularVectors">
            <summary>Returns the U matrix of Singular Vectors.</summary>        
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Ordering">
            <summary>Returns the ordering in which the singular values have been sorted.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition">
            <summary>
              Determines the Generalized eigenvalues and eigenvectors of two real square matrices.
            </summary>
            <remarks>
              <para>
                A generalized eigenvalue problem is the problem of finding a vector <c>v</c> that
                obeys <c>A * v = λ * B * v</c> where <c>A</c> and <c>B</c> are matrices. If <c>v</c>
                obeys this equation, with some <c>λ</c>, then we call <c>v</c> the generalized eigenvector
                of <c>A</c> and <c>B</c>, and <c>λ</c> is called the generalized eigenvalue of <c>A</c>
                and <c>B</c> which corresponds to the generalized eigenvector <c>v</c>. The possible
                values of <c>λ</c>, must obey the identity <c>det(A - λ*B) = 0</c>.</para>
              <para>
                Part of this code has been adapted from the original EISPACK routines in Fortran.</para>
             
              <para>
                References:
                <list type="bullet">
                  <item><description>
                    <a href="http://en.wikipedia.org/wiki/Generalized_eigenvalue_problem#Generalized_eigenvalue_problem">
                    http://en.wikipedia.org/wiki/Generalized_eigenvalue_problem#Generalized_eigenvalue_problem</a>
                  </description></item>
                  <item><description>
                    <a href="http://www.netlib.org/eispack/">
                    http://www.netlib.org/eispack/</a>
                  </description></item>
                </list>
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.#ctor(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Constructs a new generalized eigenvalue decomposition.</summary>
            <param name="a">The first matrix of the (A,B) matrix pencil.</param>
            <param name="b">The second matrix of the (A,B) matrix pencil.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzhes(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Boolean,System.Double[0:,0:])">
             <summary>
               Adaptation of the original Fortran QZHES routine from EISPACK.
             </summary>
             <remarks>
               This subroutine is the first step of the qz algorithm
               for solving generalized matrix eigenvalue problems,
               siam j. numer. anal. 10, 241-256(1973) by moler and stewart.
            
               This subroutine accepts a pair of real general matrices and
               reduces one of them to upper hessenberg form and the other
               to upper triangular form using orthogonal transformations.
               it is usually followed by  qzit,  qzval  and, possibly,  qzvec.
               
               For the full documentation, please check the original function.
             </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzit(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Double,System.Boolean,System.Double[0:,0:],System.Int32@)">
            <summary>
              Adaptation of the original Fortran QZIT routine from EISPACK.
            </summary>
            <remarks>
              This subroutine is the second step of the qz algorithm
              for solving generalized matrix eigenvalue problems,
              siam j. numer. anal. 10, 241-256(1973) by moler and stewart,
              as modified in technical note nasa tn d-7305(1973) by ward.
              
              This subroutine accepts a pair of real matrices, one of them
              in upper hessenberg form and the other in upper triangular form.
              it reduces the hessenberg matrix to quasi-triangular form using
              orthogonal transformations while maintaining the triangular form
              of the other matrix.  it is usually preceded by  qzhes  and
              followed by  qzval  and, possibly,  qzvec.
              
              For the full documentation, please check the original function.
            </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzval(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Double[],System.Double[],System.Double[],System.Boolean,System.Double[0:,0:])">
            <summary>
              Adaptation of the original Fortran QZVAL routine from EISPACK.
            </summary>
            <remarks>
              This subroutine is the third step of the qz algorithm
              for solving generalized matrix eigenvalue problems,
              siam j. numer. anal. 10, 241-256(1973) by moler and stewart.
              
              This subroutine accepts a pair of real matrices, one of them
              in quasi-triangular form and the other in upper triangular form.
              it reduces the quasi-triangular matrix further, so that any
              remaining 2-by-2 blocks correspond to pairs of complex
              eigenvalues, and returns quantities whose ratios give the
              generalized eigenvalues.  it is usually preceded by  qzhes
              and  qzit  and may be followed by  qzvec.
              
              For the full documentation, please check the original function.
            </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzvec(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Double[],System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
              Adaptation of the original Fortran QZVEC routine from EISPACK.
            </summary>
            <remarks>
              This subroutine is the optional fourth step of the qz algorithm
              for solving generalized matrix eigenvalue problems,
              siam j. numer. anal. 10, 241-256(1973) by moler and stewart.
              
              This subroutine accepts a pair of real matrices, one of them in
              quasi-triangular form (in which each 2-by-2 block corresponds to
              a pair of complex eigenvalues) and the other in upper triangular
              form.  It computes the eigenvectors of the triangular problem and
              transforms the results back to the original coordinate system.
              it is usually preceded by  qzhes,  qzit, and  qzval.
              
              For the full documentation, please check the original function.
            </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.RealAlphas">
            <summary>Returns the real parts of the alpha values.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.ImaginaryAlphas">
            <summary>Returns the imaginary parts of the alpha values.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.Betas">
            <summary>Returns the beta values.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.IsSingular">
            <summary>
              Returns true if matrix B is singular.
            </summary>
            <remarks>
              This method checks if any of the generated betas is zero. It
              does not says that the problem is singular, but only that one
              of the matrices of the pencil (A,B) is singular.
            </remarks>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.IsDegenerate">
            <summary>
              Returns true if the eigenvalue problem is degenerate (ill-posed).
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
            <remarks>
              The eigenvalues are computed using the ratio alpha[i]/beta[i],
              which can lead to valid, but infinite eigenvalues.
            </remarks>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>	
            <remarks>
              The eigenvalues are computed using the ratio alpha[i]/beta[i],
              which can lead to valid, but infinite eigenvalues.
            </remarks>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedLuDecomposition">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.JaggedLuDecomposition.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Solve(System.Double[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.SolveTranspose(System.Double[][])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Solve(System.Double[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedCholeskyDecomposition">
            <summary>
                   Cholesky Decomposition of a symmetric, positive definite matrix.
               </summary>
            <remarks>
              <para>
                   For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                   lower triangular matrix <c>L</c> so that <c>A = L * L'</c>. The presented algorithm
                   only checks the upper triangular part of the matrix given as parameter and assumes
                   it is symmetric. If the matrix is not positive definite, the constructor returns a 
                   partial decomposition and sets two internal variables that can be queried using the
                   <see cref="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new Cholesky Decomposition.
            </summary>
            
            <param name="value">
              The symmetric matrix, given in upper triangular form, to be decomposed.</param>
            <param name="robust">
              True to perform a square-root free LDLt decomposition, false otherwise.</param>
            <param name="inPlace">
              True to perform the decomposition in place, storing the factorization in the
              lower triangular part of the given matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[][],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[])">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.InverseDiagonal(System.Boolean)">
            <summary>
              Computes the diagonal of the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.InverseDiagonal(System.Double[],System.Boolean)">
             <summary>
               Computes the diagonal of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the proccess. Pass false otherwise.</param>
             <param name="result">The array to hold the result of the 
                computation. Should be of same length as the the diagonal
                of the original matrix.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.InverseTrace(System.Boolean)">
             <summary>
               Computes the trace of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the proccess. Pass false otherwise.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.FromLeftTriangularMatrix(System.Double[][])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.PositiveDefinite">
            <summary>
              Returns <see langword="true"/> if the matrix is positive definite.
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.IsNotDefined">
            <summary>
              Gets a value indicating whether the LDLt factorization
              has been computed successfully or if it is undefined.
            </summary>
            
            <value>
                <c>true</c> if the factorization is not defined; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.LeftTriangularFactor">
            <summary>
              Returns the left (lower) triangular factor
              <c>L</c> so that <c>A = L * D * L'</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.DiagonalMatrix">
            <summary>
              Returns the block diagonal matrix of diagonal
              elements in a LDLt decomposition.
            </summary>        
              
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Diagonal">
            <summary>
              Returns the one-dimensional array of diagonal 
              elements in a LDLt decomposition.
            </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Determinant">
            <summary>
              Returns the determinant of
              the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.LogDeterminant">
            <summary>
              If the matrix is positive-definite, returns the
              log-determinant of the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Nonsingular">
            <summary>
              Gets a value indicating whether the decomposed
              matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Gamma">
            <summary>
              Set of special mathematic functions.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
              </list>
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Gamma.GammaMax">
            <summary>Maximum gamma on the machine.</summary>
        </member>
        <member name="M:Accord.Math.Gamma.Function(System.Double)">
            <summary>
              Gamma function of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.UpperIncomplete(System.Double,System.Double)">
            <summary>
              Upper incomplete regularized gamma function Q.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.LowerIncomplete(System.Double,System.Double)">
            <summary>
              Lower incomplete regularized gamma function P.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Digamma(System.Double)">
            <summary>
              Digamma function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Trigamma(System.Double)">
            <summary>
              Trigamma function.
            </summary>
            
            <remarks>
              This code has been adapted from the FORTRAN77 and subsequent
              C code by B. E. Schneider and John Burkardt. The code had been
              made public under the GNU LGPL license.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Gamma.Stirling(System.Double)">
            <summary>
              Gamma function as computed by Stirling's formula.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.ComplementedIncomplete(System.Double,System.Double)">
            <summary>
              Complemented incomplete gamma function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Incomplete(System.Double,System.Double)">
            <summary>
              Incomplete gamma function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Log(System.Double)">
            <summary>
              Natural logarithm of gamma function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.OptimizationProgressEventArgs">
            <summary>
              Optimization progress event arguments.
            </summary>
        </member>
        <member name="M:Accord.Math.Optimization.OptimizationProgressEventArgs.#ctor(System.Int32,System.Int32,System.Double[],System.Double,System.Double[],System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.OptimizationProgressEventArgs"/> class.
            </summary>
            
            <param name="iteration">The current iteration of the optimization method.</param>
            <param name="evaluations">The number of function evaluations performed.</param>
            <param name="gradient">The current gradient of the function.</param>
            <param name="gnorm">The norm of the current gradient</param>
            <param name="xnorm">The norm of the current parameter vector.</param>
            <param name="solution">The current solution parameters.</param>
            <param name="value">The value of the function evaluated at the current solution.</param>
            <param name="stp">The current step size.</param>
            <param name="finished"><c>True</c> if the method is about to terminate, <c>false</c> otherwise.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Iteration">
            <summary>
              Gets the current iteration of the method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Evaluations">
            <summary>
              Gets the number of function evaluations performed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Gradient">
            <summary>
              Gets the current gradient of the function being optimized.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.GradientNorm">
            <summary>
              Gets the norm of the current <see cref="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Gradient"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Solution">
            <summary>
              Gets the current solution parameters for the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.SolutionNorm">
            <summary>
              Gets the norm of the current <see cref="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Value">
            <summary>
              Gets the value of the function to be optimized
              at the current proposed <see cref="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Step">
            <summary>
              Gets the current step size.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Finished">
            <summary>
              Gets or sets a value indicating whether the
              optimization process is about to terminate.
            </summary>
            
            <value><c>true</c> if finished; otherwise, <c>false</c>.</value>
            
        </member>
        <member name="T:Accord.Math.Optimization.NonlinearConstraint">
            <summary>
              Constraint with only linear terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.GetViolation(System.Double[])">
            <summary>
              Gets how much the constraint is being violated.
            </summary>
            
            <param name="x">The function point.</param>
            
            <returns>How much the constraint is being violated at the given point.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Linq.Expressions.Expression{System.Func{System.Double}},Accord.Math.Optimization.ConstraintType,System.Double,System.Linq.Expressions.Expression{System.Func{System.Double[]}},System.Double)">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            
            <param name="function">A lambda expression defining the left hand side of the constraint equation.</param>
            <param name="gradient">A lambda expression defining the gradient of the <paramref name="function">
            left hand side of the constraint equation</paramref>.</param>
            <param name="shouldBe">How the left hand side of the constraint should be compared to the given <paramref name="value"/>.</param>
            <param name="value">The right hand side of the constraint equation.</param>
            <param name="withinTolerance">The tolerance for violations of the constraint. Equality
              constraints should set this to a small positive value. Default is 0.</param>
            
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Func{System.Double[],System.Double},Accord.Math.Optimization.ConstraintType,System.Double,System.Func{System.Double[],System.Double[]},System.Double)">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            
            <param name="function">A lambda expression defining the left hand side of the constraint equation.</param>
            <param name="gradient">A lambda expression defining the gradient of the <paramref name="function">
            left hand side of the constraint equation</paramref>.</param>
            <param name="shouldBe">How the left hand side of the constraint should be compared to the given <paramref name="value"/>.</param>
            <param name="value">The right hand side of the constraint equation.</param>
            <param name="withinTolerance">The tolerance for violations of the constraint. Equality
              constraints should set this to a small positive value. Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor">
            <summary>
              Creates an empty nonlinear constraint.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.Create(Accord.Math.Optimization.IObjectiveFunction,System.Func{System.Double[],System.Double},Accord.Math.Optimization.ConstraintType,System.Double,System.Func{System.Double[],System.Double[]},System.Double)">
            <summary>
               Creates a nonlinear constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.NumberOfVariables">
            <summary>
              Gest the number of variables in the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Function">
            <summary>
              Gets the left hand side of 
              the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Gradient">
            <summary>
              Gets the gradient of the left hand
              side of the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.ShouldBe">
            <summary>
              Gets the type of the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Value">
            <summary>
              Gets the value in the right hand
              side of the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Tolerance">
            <summary>
              Gets the violation tolerance for the constraint. Equality
              constraints should set this to a small positive value.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.SingularValueDecomposition">
            <summary>
              Singular Value Decomposition for a rectangular matrix.
            </summary>
            <remarks>
             <para>
                 For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the singular value decomposition
              is an m-by-n orthogonal matrix <c>U</c>, an n-by-n diagonal matrix <c>S</c>, and
              an n-by-n orthogonal matrix <c>V</c> so that <c>A = U * S * V'</c>.
              The singular values, <c>sigma[k] = S[k,k]</c>, are ordered so that
              <c>sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1]</c>.</para>
             <para>
              The singular value decomposition always exists, so the constructor will
              never fail. The matrix condition number and the effective numerical
              rank can be computed from this decomposition.</para>
             <para>
              WARNING! Please be aware that if A has less rows than columns, it is better
              to compute the decomposition on the transpose of A and then swap the left
              and right eigenvectors. If the routine is computed on A directly, the diagonal
              of singular values may contain one or more zeros. The identity A = U * S * V'
              may still hold, however. To overcome this problem, pass true to the
              <see cref="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean,System.Boolean)">autoTranspose</see> argument of the class constructor.</para>
             <para>
              This routine computes the economy decomposition of A.</para> 
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:])">
            <summary>Constructs a new singular value decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new singular value decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean,System.Boolean)">
            <summary>Constructs a new singular value decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Constructs a new singular value decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Solve(System.Double[0:,0:])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.SolveForDiagonal(System.Double[])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Solve(System.Double[])">
            <summary>
              Solves a linear equation system of the form Ax = b.
            </summary>
            <param name="value">The b from the equation Ax = b.</param>
            <returns>The x from equation Ax = b.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Inverse">
             <summary>
               Computes the (pseudo-)inverse of the matrix given to the Singular value decomposition.
             </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Clone">
             <summary>
               Creates a new object that is a copy of the current instance.
             </summary>
             <returns>
               A new object that is a copy of this instance.
             </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Condition">
             <summary>
               Returns the condition number <c>max(S) / min(S)</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Threshold">
             <summary>
               Returns the singularity threshold.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.TwoNorm">
             <summary>
               Returns the Two norm.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Rank">
            <summary>Returns the effective numerical matrix rank.</summary>
            <value>Number of non-negligible singular values.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Diagonal">
            <summary>Returns the one-dimensional array of singular values.</summary>        
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.DiagonalMatrix">
            <summary>Returns the block diagonal matrix of singular values.</summary>        
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.RightSingularVectors">
            <summary>Returns the V matrix of Singular Vectors.</summary>        
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.LeftSingularVectors">
            <summary>Returns the U matrix of Singular Vectors.</summary>        
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Ordering">
            <summary>Returns the ordering in which the singular values have been sorted.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.LuDecompositionF">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.LuDecompositionF.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Solve(System.Single[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.SolveTranspose(System.Single[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.ReducedRowEchelonForm">
            <summary>
              Reduced row Echelon form
            </summary>
            
        </member>
        <member name="M:Accord.Math.ReducedRowEchelonForm.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Reduces a matrix to reduced row Echelon form.
            </summary>
            
            <param name="value">The matrix to be reduced.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the reduction in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
              
        </member>
        <member name="P:Accord.Math.ReducedRowEchelonForm.Pivot">
            <summary>
              Gets the pivot indicating the position
              of the original rows before the swap.
            </summary>
            
        </member>
        <member name="P:Accord.Math.ReducedRowEchelonForm.Result">
            <summary>
              Gets the matrix in row reduced Echelon form.
            </summary>
        </member>
        <member name="P:Accord.Math.ReducedRowEchelonForm.FreeVariables">
            <summary>
              Gets the number of free variables (linear
              dependent rows) in the given matrix.
            </summary>
        </member>
        <member name="T:Accord.Math.Distance">
            <summary>
              Static class Distance. Defines a set of extension methods defining distance measures.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.SquareMahalanobis(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
              Gets the Square Mahalanobis distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="precision">
              The inverse of the covariance matrix of the distribution for the two points x and y.
            </param>
            
            <returns>The Square Mahalanobis distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Mahalanobis(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
              Gets the Mahalanobis distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="precision">
              The inverse of the covariance matrix of the distribution for the two points x and y.
            </param>
            
            <returns>The Mahalanobis distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Manhattan(System.Double[],System.Double[])">
            <summary>
              Gets the Manhattan distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The manhattan distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Manhattan(System.Int32[],System.Int32[])">
            <summary>
              Gets the Manhattan distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The manhattan distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Chebyshev(System.Double[],System.Double[])">
            <summary>
              Gets the Chebyshev distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The chebyshev distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.SquareEuclidean(System.Double[],System.Double[])">
            <summary>
              Gets the Square Euclidean distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Square Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.SquareEuclidean(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Gets the Square Euclidean distance between two points.
            </summary>
            
            <param name="x1">The first coordinate of first point in space.</param>
            <param name="y1">The second coordinate of first point in space.</param>
            <param name="x2">The first coordinate of second point in space.</param>
            <param name="y2">The second coordinate of second point in space.</param>
            
            <returns>The Square Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Euclidean(System.Double[],System.Double[])">
            <summary>
              Gets the Euclidean distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Euclidean(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Gets the Euclidean distance between two points.
            </summary>
            
            <param name="x1">The first coordinate of first point in space.</param>
            <param name="y1">The second coordinate of first point in space.</param>
            <param name="x2">The first coordinate of second point in space.</param>
            <param name="y2">The second coordinate of second point in space.</param>
            
            <returns>The Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Modular(System.Int32,System.Int32,System.Int32)">
            <summary>
              Gets the Modulo-m distance between two integers a and b.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[],System.Double[])">
            <summary>
              Bhattacharyya distance between two normalized histograms.
            </summary>
            
            <param name="histogram1">A normalized histogram.</param>
            <param name="histogram2">A normalized histogram.</param>
            <returns>The Bhattacharya distance between the two histograms.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Bhattacharyya distance between two matrices.
            </summary>
            
            <returns>The Bhattacharia distance between the two matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[],System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Bhattacharyya distance between two gaussian distributions.
            </summary>
            
            <param name="meanX">Mean for the first distribution.</param>
            <param name="covX">Covariance matrix for the first distribution.</param>
            <param name="meanY">Mean for the second distribution.</param>
            <param name="covY">Covariance matrix for the second distribution.</param>
            <returns>The Bhattacharia distance between the two distributions.</returns>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedLuDecompositionF">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.JaggedLuDecompositionF.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Solve(System.Single[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.SolveTranspose(System.Single[][])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.ConstraintType">
            <summary>
              Constraint type.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConstraintType.EqualTo">
            <summary>
              Equality constraint.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConstraintType.GreaterThanOrEqualTo">
            <summary>
              Inequality constraint specifying a greater than or equal to relationship.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConstraintType.LesserThanOrEqualTo">
            <summary>
              Inequality constraint specifying a lesser than or equal to relationship.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.LinearConstraint">
            <summary>
              Constraint with only linear terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(System.Int32)">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the constraint.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(System.Double[])">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="coefficients">The scalar coefficients specifying how variables should be combined in the constraint.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.String)">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="function">The objective function to which this constraint refers to.</param>
            <param name="constraint">A <see cref="T:System.String"/> specifying this constraint, such as "ax + b = c".</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="function">The objective function to which this constraint refers to.</param>
            <param name="constraint">A <see cref="T:System.Linq.Expressions.Expression`1"/> specifying this constraint in the form of a lambda expression.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.NumberOfVariables">
            <summary>
              Gest the number of variables in the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.VariablesAtIndices">
            <summary>
              Gets the index of the variables (in respective to the
              object function index) of the variables participating
              in this constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.CombinedAs">
            <summary>
              Gets the scalar coefficients combining the <see cref="P:Accord.Math.Optimization.LinearConstraint.VariablesAtIndices">
              variables</see> specified by the constraints.
            </summary>
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.ShouldBe">
            <summary>
              Gets the type of the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.Value">
            <summary>
              Gets the value to be compared to the combined values
              of the variables.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Formats.OctaveArrayFormatProvider">
            <summary>
              Format provider for the matrix format used by Octave.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Formats.OctaveArrayFormatProvider.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Math.Formats.OctaveMatrixFormatProvider"/> class.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.OctaveArrayFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Formats.OctaveArrayFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.LuDecompositionD">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.LuDecompositionD.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.#ctor(System.Decimal[0:,0:])">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Solve(System.Decimal[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.SolveTranspose(System.Decimal[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Solve(System.Decimal[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.NonlinearObjectiveFunction">
            <summary>
              Quadractic objective function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearObjectiveFunction.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="numberOfVariables">The number of parameters in the <paramref name="function"/>.</param>
            <param name="function">A lambda expression defining the objective
              function.</param>
            <param name="gradient">A lambda expression defining the gradient
              of the <paramref name="function">objective function</paramref>.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearObjectiveFunction.#ctor(System.Linq.Expressions.Expression{System.Func{System.Double}},System.Linq.Expressions.Expression{System.Func{System.Double[]}})">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="function">A <see cref="T:System.Linq.Expressions.Expression`1"/> containing 
              the function in the form of a lambda expression.</param>
            <param name="gradient">A <see cref="T:System.Linq.Expressions.Expression`1"/> containing 
              the the gradient of the <paramref name="function">objective function</paramref>.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Variables">
            <summary>
              Gets input variable's labels for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Indices">
            <summary>
              Gets the index of each input variable in the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Function">
            <summary>
              Gets the objective function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Gradient">
            <summary>
              Gets the gradient of the <see cref="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Function">objective function</see>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.NumberOfVariables">
            <summary>
              Gets the number of input variables for the function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Geometry.ConvexityDefect">
            <summary>
              Convexity defect.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.ConvexityDefect.#ctor(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.ConvexityDefect"/> class.
            </summary>
            
            <param name="point">The most distant point from the hull.</param>
            <param name="start">The starting index of the defect in the contour.</param>
            <param name="end">The ending index of the defect in the contour.</param>
            <param name="depth">The depth of the defect (highest distance from the hull to
            any of the contour points).</param>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.Start">
            <summary>
              Gets or sets the starting index of the defect in the contour.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.End">
            <summary>
              Gets or sets the ending index of the defect in the contour.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.Point">
            <summary>
              Gets or sets the most distant point from the hull characterizing the defect.
            </summary>
            
            <value>The point.</value>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.Depth">
            <summary>
              Gets or sets the depth of the defect (highest distance
              from the hull to any of the points in the contour).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Geometry.ConvexHullDefects">
            <summary>
              Convex Hull Defects Extractor.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.ConvexHullDefects.#ctor(System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.ConvexHullDefects"/> class.
            </summary>
            
            <param name="minDepth">The minimum depth which characterizes a convexity defect.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.ConvexHullDefects.FindDefects(System.Collections.Generic.List{AForge.IntPoint},System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
              Finds the convexity defects in a contour given a convex hull.
            </summary>
            
            <param name="contour">The contour.</param>
            <param name="convexHull">The convex hull of the contour.</param>
            <returns>A list of <see cref="T:Accord.Math.Geometry.ConvexityDefect"/>s containing each of the
            defects found considering the convex hull of the contour.</returns>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexHullDefects.MinimumDepth">
            <summary>
            Gets or sets the minimum depth which characterizes a convexity defect.
            </summary>
            
            <value>The minimum depth.</value>
            
        </member>
        <member name="T:Accord.Math.Formats.DefaultMatrixFormatProvider">
            <summary>
              Gets the default matrix representation, where each row
              is separated by a new line, and columns are separated by spaces.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Formats.DefaultMatrixFormatProvider.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Math.Formats.DefaultMatrixFormatProvider"/> class.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.DefaultMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Formats.DefaultMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Formats.CSharpArrayFormatProvider">
            <summary>
              Gets the matrix representation used in C# multi-dimensional arrays.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Formats.CSharpArrayFormatProvider.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Math.Formats.CSharpMatrixFormatProvider"/> class.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.CSharpArrayFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Formats.CSharpArrayFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedLuDecompositionD">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.JaggedLuDecompositionD.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.#ctor(System.Decimal[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Solve(System.Decimal[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.SolveTranspose(System.Decimal[][])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Solve(System.Decimal[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Special">
            <summary>
              Set of special mathematic functions.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  John D. Cook, http://www.johndcook.com/ </description></item>
              </list>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Special.Erfc(System.Double)">
            <summary>
              Complementary error function of the specified value.
            </summary>
            
            <remarks>
              http://mathworld.wolfram.com/Erfc.html
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Special.Erf(System.Double)">
            <summary>
              Error function of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Polevl(System.Double,System.Double[],System.Int32)">
            <summary>
              Evaluates polynomial of degree N
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.P1evl(System.Double,System.Double[],System.Int32)">
            <summary>
              Evaluates polynomial of degree N with assumption that coef[N] = 1.0
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.BSpline(System.Int32,System.Double)">
            <summary>
              Computes the Basic Spline of order <c>n</c>
            </summary>
        </member>
        <member name="M:Accord.Math.Special.Binomial(System.Int32,System.Int32)">
            <summary>
              Computes the binomial coefficients C(n,k).
            </summary>
        </member>
        <member name="M:Accord.Math.Special.LogBinomial(System.Int32,System.Int32)">
            <summary>
              Computes the log binomial Coefficients Log[C(n,k)].
            </summary>
        </member>
        <member name="M:Accord.Math.Special.LogFactorial(System.Int32)">
            <summary>
              Returns the log factorial of a number (ln(n!))
            </summary>
        </member>
        <member name="M:Accord.Math.Special.Factorial(System.Int32)">
            <summary>
              Computes the factorial of a number (n!)
            </summary>
        </member>
        <member name="M:Accord.Math.Special.Log1m(System.Double)">
            <summary>
              Computes log(1-x) without losing precision for small values of x.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Log1p(System.Double)">
            <summary>
              Computes log(1+x) without losing precision for small values of x.
            </summary>
            
            <remarks>
              References:
              - http://www.johndcook.com/csharp_log_one_plus_x.html
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Special.Expm1(System.Double)">
            <summary>
              Compute exp(x) - 1 without loss of precision for small values of x.
            </summary>
            <remarks>
              References:
              - http://www.johndcook.com/cpp_expm1.html
            </remarks>
        </member>
        <member name="M:Accord.Math.Special.Epslon(System.Double)">
            <summary>
              Estimates unit roundoff in quantities of size x.
            </summary>
            <remarks>
              This is a port of the epslon function from EISPACK.
            </remarks>
        </member>
        <member name="M:Accord.Math.Special.Sign(System.Double,System.Double)">
            <summary>
              Returns A with the sign of B.
            </summary>
            <remarks>
              This is a port of the sign transfer function from EISPACK.
            </remarks>
            <returns>If B > 0 then the result is ABS(A), else it is -ABS(A).</returns>
        </member>
        <member name="M:Accord.Math.Special.LogDiff(System.Double,System.Double)">
            <summary>
              Computes x + y without losing precision using ln(x) and ln(y).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogSum(System.Double,System.Double)">
            <summary>
              Computes x + y without losing precision using ln(x) and ln(y).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogSum(System.Single,System.Single)">
            <summary>
              Computes x + y without losing precision using ln(x) and ln(y).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Formats.DefaultArrayFormatProvider">
            <summary>
              Gets the default matrix representation, where each row
              is separated by a new line, and columns are separated by spaces.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Formats.DefaultArrayFormatProvider.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Math.Formats.DefaultArrayFormatProvider"/> class.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.DefaultArrayFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Formats.DefaultArrayFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.QrDecompositionF">
            <summary>
                 QR decomposition for a rectangular matrix.
            </summary>
            <remarks>
            <para>
              For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
              is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
              matrix <c>R</c> so that <c>A = Q * R</c>.</para>
            <para>
              The QR decomposition always exists, even if the matrix does not have
              full rank, so the constructor will never fail. The primary use of the
              QR decomposition is in the least squares solution of nonsquare systems
              of simultaneous linear equations.
              This will fail if <see cref="P:Accord.Math.Decompositions.QrDecompositionF.FullRank"/> returns <see langword="false"/>.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Solve(System.Single[0:,0:])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.SolveTranspose(System.Single[0:,0:])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Solve(System.Single[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.EigenvalueDecompositionF">
            <summary>
                Determines the eigenvalues and eigenvectors of a real square matrix.
            </summary>
            <remarks>
              <para>
                In the mathematical discipline of linear algebra, eigendecomposition
                or sometimes spectral decomposition is the factorization of a matrix
                into a canonical form, whereby the matrix is represented in terms of
                its eigenvalues and eigenvectors.</para>
              <para>
                If <c>A</c> is symmetric, then <c>A = V * D * V'</c> and <c>A = V * V'</c>
                where the eigenvalue matrix <c>D</c> is diagonal and the eigenvector matrix <c>V</c> is orthogonal.
                If <c>A</c> is not symmetric, the eigenvalue matrix <c>D</c> is block diagonal
                with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
                <c>lambda + i*mu</c>, in 2-by-2 blocks, <c>[lambda, mu; -mu, lambda]</c>.
                The columns of <c>V</c> represent the eigenvectors in the sense that <c>A * V = V * D</c>.
                The matrix V may be badly conditioned, or even singular, so the validity of the equation
                <c>A = V * D * inverse(V)</c> depends upon the condition of <c>V</c>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>    
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Beta">
            <summary>
              Beta functions.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
              </list>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Beta.Function(System.Double,System.Double)">
            <summary>
              Beta function as gamma(a) * gamma(b) / gamma(a+b).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Beta.Log(System.Double,System.Double)">
            <summary>
              Natural logarithm of the Beta function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Beta.Incomplete(System.Double,System.Double,System.Double)">
            <summary>
              Incomplete (regularized) Beta function Ix(a, b).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Beta.Incbcf(System.Double,System.Double,System.Double)">
            <summary>
              Continued fraction expansion #1 for incomplete beta integral.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Beta.Incbd(System.Double,System.Double,System.Double)">
            <summary>
              Continued fraction expansion #2 for incomplete beta integral.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Beta.IncompleteInverse(System.Double,System.Double,System.Double)">
            <summary>
              Inverse of incomplete beta integral.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Beta.PowerSeries(System.Double,System.Double,System.Double)">
            <summary>
              Power series for incomplete beta integral. Use when b*x
              is small and x not too close to 1.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.AugmentedLagrangianSolver">
             <summary>
               Augmented Lagrangiam method for constrained non-linear optimization.
             </summary>
             
             <remarks>
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://ab-initio.mit.edu/nlopt">
                   Steven G. Johnson, The NLopt nonlinear-optimization package, http://ab-initio.mit.edu/nlopt </a></description></item>
                 <item><description><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.72.6121">
                   E. G. Birgin and J. M. Martinez, "Improving ultimate convergence of an augmented Lagrangian
                   method," Optimization Methods and Software vol. 23, no. 2, p. 177-195 (2008). </a></description></item>
               </list>
             </para>   
             </remarks>
             
             <example>
             <para>
               In this framework, it is possible to state a non-linear programming problem
               using either symbolic processing or vector-valued functions. The following 
               example demonstrates the former.</para>
               
             <code>
             // Suppose we would like to minimize the following function:
             //
             //    f(x,y) = min 100(y-x²)²+(1-x)²
             //
             // Subject to the constraints
             //
             //    x >= 0  (x must be positive)
             //    y >= 0  (y must be positive)
             //
            
             // In this example we will be using some symbolic processing. 
             // The following variables could be inicialized to any value.
            
             double x = 0, y = 0;
            
            
             // First, we create our objective function
             var f = new NonlinearObjectiveFunction(
            
                 // This is the objective function:  f(x,y) = min 100(y-x²)²+(1-x)²
                 function: () => 100 * Math.Pow(y - x * x, 2) + Math.Pow(1 - x, 2),
            
                 // The gradient vector:
                 gradient: () => new[] 
                 {
                     2 * (200 * Math.Pow(x, 3) - 200 * x * y + x - 1), // df/dx = 2(200x³-200xy+x-1)
                     200 * (y - x*x)                                   // df/dy = 200(y-x²)
                 }
            
             );
            
            
             // Now we can start stating the constraints
             var constraints = new List&lt;NonlinearConstraint>();
            
             // Add the non-negativity constraint for x
             constraints.Add(new NonlinearConstraint(f,
            
                 // 1st contraint: x should be greater than or equal to 0
                 function: () => x, shouldBe: ConstraintType.GreaterThanOrEqualTo, value: 0,
            
                 gradient: () => new[] { 1.0, 0.0 }
             ));
            
             // Add the non-negativity constraint for y
             constraints.Add(new NonlinearConstraint(f,
            
                 // 2nd constraint: y should be greater than or equal to 0
                 function: () => y, shouldBe: ConstraintType.GreaterThanOrEqualTo, value: 0,
            
                 gradient: () => new[] { 0.0, 1.0 }
             ));
            
            
             // Finally, we create the non-linear programming solver
             var solver = new AugmentedLagrangianSolver(2, constraints);
            
             // And attempt to solve the problem
             double minValue = solver.Minimize(f);
             </code>
             </example>
             
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.#ctor(System.Int32,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.NonlinearConstraint})">
            <summary>
              Creates a new instance of the Augmented Lagrangian algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            <param name="constraints">The <see cref="T:Accord.Math.Optimization.NonlinearConstraint"/>s to which the solution must be subjected.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Minimize(Accord.Math.Optimization.NonlinearObjectiveFunction)">
            <summary>
              Minimizes the given function. 
            </summary>
            
            <param name="function">The function to be minimized.</param>
            
            <returns>The minimum value found at the <see cref="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Solution"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Minimize(System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Minimizes the defined function. 
            </summary>
            
            <param name="function">The function to be minimized.</param>
            <param name="gradient">The gradient of the given <paramref name="function"/>.</param>
            
            <returns>The minimum value found at the <see cref="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Solution"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Maximize(Accord.Math.Optimization.NonlinearObjectiveFunction)">
            <summary>
              Maximizes the given function. 
            </summary>
            
            <param name="function">The function to be maximized.</param>
            
            <returns>The maximum value found at the <see cref="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Solution"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Maximize(System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              maximizes the defined function. 
            </summary>
            
            <param name="function">The function to be maximized.</param>
            <param name="gradient">The gradient of the given <paramref name="function"/>.</param>
            
            <returns>The maximum value found at the <see cref="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Solution"/>.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Parameters">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Iterations">
            <summary>
              Gets the number of iterations performed in the last
              call to <see cref="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Minimize(Accord.Math.Optimization.NonlinearObjectiveFunction)"/>.
            </summary>
            
            <value>
              The number of iterations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Evaluations">
            <summary>
              Gets the number of function evaluations performed
              in the last call to <see cref="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Minimize(Accord.Math.Optimization.NonlinearObjectiveFunction)"/>.
            </summary>
            
            <value>
              The number of evaluations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.MaxEvaluations">
            <summary>
              Gets or sets the maximum number of evaluations
              to be performed during optimization. Default
              is 0 (evaluate until convergence).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Function">
            <summary>
              Gets or sets the function to be optimized.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Gradient">
            <summary>
              Gets or sets a function returning the gradient
              vector of the function to be optimized for a
              given value of its free parameters.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Solution">
            <summary>
              Gets the solution found, the values of the
              parameters which optimizes the function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Norm">
            <summary>
              Static class Norm. Defines a set of extension methods defining norms measures.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Norm1(System.Double[0:,0:])">
            <summary>
              Returns the maximum column sum of the given matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Norm2(System.Double[0:,0:])">
            <summary>
              Returns the maximum singular value of the given matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Frobenius(System.Double[0:,0:])">
            <summary>
              Gets the square root of the sum of squares for all elements in a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Single[])">
            <summary>
              Gets the Squared Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[])">
            <summary>
              Gets the Squared Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Single[])">
            <summary>
              Gets the Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Double[])">
            <summary>
              Gets the Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[0:,0:])">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[0:,0:],System.Int32)">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Double[0:,0:])">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Double[0:,0:],System.Int32)">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Single[0:,0:],System.Int32)">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Single[0:,0:])">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Single[0:,0:],System.Int32)">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.EigenvalueDecomposition">
            <summary>
                Determines the eigenvalues and eigenvectors of a real square matrix.
            </summary>
            <remarks>
              <para>
                In the mathematical discipline of linear algebra, eigendecomposition
                or sometimes spectral decomposition is the factorization of a matrix
                into a canonical form, whereby the matrix is represented in terms of
                its eigenvalues and eigenvectors.</para>
              <para>
                If <c>A</c> is symmetric, then <c>A = V * D * V'</c> and <c>A = V * V'</c>
                where the eigenvalue matrix <c>D</c> is diagonal and the eigenvector matrix <c>V</c> is orthogonal.
                If <c>A</c> is not symmetric, the eigenvalue matrix <c>D</c> is block diagonal
                with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
                <c>lambda + i*mu</c>, in 2-by-2 blocks, <c>[lambda, mu; -mu, lambda]</c>.
                The columns of <c>V</c> represent the eigenvectors in the sense that <c>A * V = V * D</c>.
                The matrix V may be badly conditioned, or even singular, so the validity of the equation
                <c>A = V * D * inverse(V)</c> depends upon the condition of <c>V</c>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.#ctor(System.Double[0:,0:])">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>    
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.CholeskyDecompositionF">
            <summary>
                Cholesky Decomposition of a symmetric, positive definite matrix.
            </summary>
            <remarks>
              <para>
                For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                lower triangular matrix <c>L</c> so that <c>A = L * L'</c>.
                If the matrix is not symmetric or positive definite, the constructor returns a partial 
                decomposition and sets two internal variables that can be queried using the
                <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionF.Symmetric"/> and <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionF.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            <param name="value">The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square root free LDLt decomposition,
            false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square-root free LDLt decomposition,
            false otherwise.</param>
            <param name="lowerTriangular">True to assume the <paramref name="value">value
            matrix</paramref> is a lower triangular symmetric matrix, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[0:,0:])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is not symmetric and positive definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[0:,0:],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * x = b</c>.</summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Inverse">
            <summary>
              Computes the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.FromLeftTriangularMatrix(System.Single[0:,0:])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Symmetric">
             <summary>
               Returns <see langword="true"/> if the matrix is symmetric.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.PositiveDefinite">
             <summary>
               Returns <see langword="true"/> if the matrix is positive definite.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.LeftTriangularFactor">
             <summary>
               Returns the left (lower) triangular factor <c>L</c> so that <c>A = L * D * L'</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.DiagonalMatrix">
             <summary>
               Returns the block diagonal matrix of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Diagonal">
             <summary>
               Returns the one-dimensional array of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Determinant">
             <summary>
               Returns the determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.LogDeterminant">
             <summary>
               Returns the log-determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Nonsingular">
             <summary>
               Returns if the matrix is non-singular (i.e. invertible).
             </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.CholeskyDecomposition">
            <summary>
                Cholesky Decomposition of a symmetric, positive definite matrix.
            </summary>
            <remarks>
              <para>
                For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                lower triangular matrix <c>L</c> so that <c>A = L * L'</c>.
                If the matrix is not symmetric or positive definite, the constructor returns a partial 
                decomposition and sets two internal variables that can be queried using the
                <see cref="P:Accord.Math.Decompositions.CholeskyDecomposition.Symmetric"/> and <see cref="P:Accord.Math.Decompositions.CholeskyDecomposition.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.#ctor(System.Double[0:,0:])">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            <param name="value">The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square root free LDLt decomposition,
            false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square-root free LDLt decomposition,
            false otherwise.</param>
            <param name="lowerTriangular">True to assume the <paramref name="value">value
            matrix</paramref> is a lower triangular symmetric matrix, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[0:,0:])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is not symmetric and positive definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[0:,0:],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * x = b</c>.</summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Inverse">
            <summary>
              Computes the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.FromLeftTriangularMatrix(System.Double[0:,0:])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Symmetric">
             <summary>
               Returns <see langword="true"/> if the matrix is symmetric.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.PositiveDefinite">
             <summary>
               Returns <see langword="true"/> if the matrix is positive definite.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.LeftTriangularFactor">
             <summary>
               Returns the left (lower) triangular factor <c>L</c> so that <c>A = L * D * L'</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.DiagonalMatrix">
             <summary>
               Returns the block diagonal matrix of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Diagonal">
             <summary>
               Returns the one-dimensional array of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Determinant">
             <summary>
               Returns the determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.LogDeterminant">
             <summary>
               Returns the log-determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Nonsingular">
             <summary>
               Returns if the matrix is non-singular (i.e. invertible).
             </summary>
            
        </member>
        <member name="T:Accord.Math.Wavelets.CDF97">
            <summary>
              Cohen-Daubechies-Feauveau Wavelet Transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.#ctor(System.Int32)">
            <summary>
              Constructs a new Cohen-Daubechies-Feauveau Wavelet Transform.
            </summary>
            
            <param name="levels">The number of iterations for the 2D transform.</param>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Forward(System.Double[])">
            <summary>
              1-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Forward(System.Double[0:,0:])">
            <summary>
              2-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Backward(System.Double[])">
            <summary>
              1-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Backward(System.Double[0:,0:])">
            <summary>
              2-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.FWT97(System.Double[])">
            <summary>
              Forward biorthogonal 9/7 wavelet transform
            </summary>
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.IWT97(System.Double[])">
            <summary>
              Inverse biorthogonal 9/7 wavelet transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.FWT97(System.Double[0:,0:],System.Int32)">
            <summary>
              Forward biorthogonal 9/7 2D wavelet transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.IWT97(System.Double[0:,0:],System.Int32)">
            <summary>
              Inverse biorthogonal 9/7 2D wavelet transform
            </summary>
            
        </member>
        <member name="T:Accord.Math.Bessel">
            <summary>
              Bessel functions.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
              </list>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Bessel.J0(System.Double)">
            <summary>
              Bessel function of order 0.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Bessel.J(System.Double)">
            <summary>
              Bessel function of order 1.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Bessel.J(System.Int32,System.Double)">
            <summary>
              Bessel function of order <c>n</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Bessel.Y0(System.Double)">
            <summary>
              Bessel function of the second kind, of order 0.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Bessel.Y(System.Double)">
            <summary>
              Bessel function of the second kind, of order 1.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Bessel.Y(System.Int32,System.Double)">
            <summary>
              Bessel function of the second kind, of order <c>n</c>.
            </summary>
        </member>
        <member name="M:Accord.Math.Bessel.I0(System.Double)">
            <summary>
              Bessel function of the first kind, of order 0.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Bessel.I(System.Double)">
            <summary>
              Bessel function of the first kind, of order 1.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Bessel.I(System.Int32,System.Double)">
            <summary>
              Bessel function of the first kind, of order <c>n</c>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.LineSearchFailedException">
            <summary>
              Line Search Failed Exception.
            </summary>
            
            <remarks>
              This exception may be thrown by the <see cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno">L-BFGS Optimizer</see>
              when the line search routine used by the optimization method fails.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.Int32,System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
            <param name="info">The error code information of the line search routine.</param>
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is null.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0).
            </exception>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is a null reference (Nothing in Visual Basic).
            </exception>
            <PermissionSet>
            	<IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*"/>
            	<IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter"/>
            </PermissionSet>
            
        </member>
        <member name="P:Accord.Math.Optimization.LineSearchFailedException.Information">
            <summary>
              Gets the error code information returned by the line search routine.
            </summary>
            
            <value>The error code information returned by the line search routine.</value>
            
        </member>
        <member name="T:Accord.Math.Geometry.KCurvature">
            <summary>
              K-curvatures algorithm for local contour extrema detection.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.KCurvature.#ctor(System.Int32,AForge.DoubleRange)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.KCurvature"/> class.
            </summary>
            <param name="k">The number K of previous and posterior
              points to consider when find local extremum points.</param>
            <param name="theta">The theta angle range (in
              degrees) used to define extremum points..</param>
        </member>
        <member name="M:Accord.Math.Geometry.KCurvature.FindPeaks(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
              Finds local extremum points in the contour.
            </summary>
            <param name="contour">A list of <see cref="T:AForge.IntPoint">
            integer points</see> defining the contour.</param>
            
        </member>
        <member name="P:Accord.Math.Geometry.KCurvature.K">
            <summary>
              Gets or sets the number K of previous and posterior
              points to consider when find local extremum points.
            </summary>
        </member>
        <member name="P:Accord.Math.Geometry.KCurvature.Theta">
            <summary>
              Gets or sets the theta angle range (in
              degrees) used to define extremum points.
            </summary>
        </member>
        <member name="P:Accord.Math.Geometry.KCurvature.Suppression">
            <summary>
              Gets or sets the suppression radius to
              use during non-minimum suppression.
            </summary>
        </member>
        <member name="T:Accord.Math.Formats.OctaveMatrixFormatProvider">
            <summary>
              Format provider for the matrix format used by Octave.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Formats.OctaveMatrixFormatProvider.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Math.Formats.OctaveMatrixFormatProvider"/> class.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.OctaveMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Formats.OctaveMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Formats.CSharpJaggedMatrixFormatProvider">
            <summary>
              Gets the matrix representation used in C# jagged arrays.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Formats.CSharpJaggedMatrixFormatProvider.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Math.Formats.CSharpJaggedMatrixFormatProvider"/> class.
            </summary>
        </member>
        <member name="P:Accord.Math.Formats.CSharpJaggedMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Formats.CSharpJaggedMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.QrDecompositionD">
            <summary>
                 QR decomposition for a rectangular matrix.
            </summary>
            <remarks>
            <para>
              For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
              is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
              matrix <c>R</c> so that <c>A = Q * R</c>.</para>
            <para>
              The QR decomposition always exists, even if the matrix does not have
              full rank, so the constructor will never fail. The primary use of the
              QR decomposition is in the least squares solution of nonsquare systems
              of simultaneous linear equations.
              This will fail if <see cref="P:Accord.Math.Decompositions.QrDecompositionD.FullRank"/> returns <see langword="false"/>.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.#ctor(System.Decimal[0:,0:])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Solve(System.Decimal[0:,0:])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.SolveTranspose(System.Decimal[0:,0:])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Solve(System.Decimal[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.QrDecomposition">
            <summary>
                 QR decomposition for a rectangular matrix.
            </summary>
            <remarks>
            <para>
              For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
              is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
              matrix <c>R</c> so that <c>A = Q * R</c>.</para>
            <para>
              The QR decomposition always exists, even if the matrix does not have
              full rank, so the constructor will never fail. The primary use of the
              QR decomposition is in the least squares solution of nonsquare systems
              of simultaneous linear equations.
              This will fail if <see cref="P:Accord.Math.Decompositions.QrDecomposition.FullRank"/> returns <see langword="false"/>.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.#ctor(System.Double[0:,0:])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Solve(System.Double[0:,0:])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.SolveTranspose(System.Double[0:,0:])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Solve(System.Double[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Wavelets.Haar">
            <summary>
              Haar Wavelet Transform.
            </summary>
            
            <remarks>
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Musawir Ali, An Introduction to Wavelets and the Haar Transform.
                  Available on: http://www.cs.ucf.edu/~mali/haar/ </description></item>
              </list>
            </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.#ctor(System.Int32)">
            <summary>
              Constructs a new Haar Wavelet Transform.
            </summary>
            <param name="levels">The number of iterations for the 2D transform.</param>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Forward(System.Double[])">
            <summary>
              1-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Backward(System.Double[])">
            <summary>
              1-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Forward(System.Double[0:,0:])">
            <summary>
              2-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Backward(System.Double[0:,0:])">
            <summary>
              2-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.FWT(System.Double[])">
            <summary>
              Discrete Haar Wavelet Transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.IWT(System.Double[])">
            <summary>
              Inverse Haar Wavelet Transform
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.FWT(System.Double[0:,0:],System.Int32)">
            <summary>
              Discrete Haar Wavelet 2D Transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.IWT(System.Double[0:,0:],System.Int32)">
            <summary>
              Inverse Haar Wavelet 2D Transform
            </summary>
            
        </member>
        <member name="T:Accord.Math.Tools">
            <summary>
              Set of mathematical tools.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.SetupGenerator(System.Int32)">
            <summary>
              Sets a random seed for the internal number generator.
            </summary>
        </member>
        <member name="M:Accord.Math.Tools.Angle(System.Single,System.Single)">
            <summary>
              Gets the angle formed by the vector [x,y].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Angle(System.Double,System.Double)">
            <summary>
              Gets the angle formed by the vector [x,y].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Angle(AForge.IntPoint,AForge.IntPoint)">
            <summary>
              Gets the displacement angle between two points.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Direction(AForge.IntPoint,AForge.IntPoint)">
            <summary>
              Gets the displacement angle between two points, coded
              as an integer varying from 0 to 20.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.NextPowerOf2(System.Int32)">
            <summary>
              Returns the next power of 2 after the input value x.
            </summary>
            
            <param name="x">Input value x.</param>
            <returns>Returns the next power of 2 after the input value x.</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.PreviousPowerOf2(System.Int32)">
            <summary>
              Returns the previous power of 2 after the input value x.
            </summary>
            
            <param name="x">Input value x.</param>
            <returns>Returns the previous power of 2 after the input value x.</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Hypotenuse(System.Double,System.Double)">
            <summary>
              Hypotenuse calculus without overflow/underflow
            </summary>
            
            <param name="a">first value</param>
            <param name="b">second value</param>
            <returns>The hypotenuse Sqrt(a^2 + b^2)</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Hypotenuse(System.Decimal,System.Decimal)">
            <summary>
              Hypotenuse calculus without overflow/underflow
            </summary>
            
            <param name="a">first value</param>
            <param name="b">second value</param>
            <returns>The hypotenuse Sqrt(a^2 + b^2)</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Hypotenuse(System.Single,System.Single)">
            <summary>
              Hypotenuse calculus without overflow/underflow
            </summary>
            
            <param name="a">first value</param>
            <param name="b">second value</param>
            <returns>The hypotenuse Sqrt(a^2 + b^2)</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Mod(System.Int32,System.Int32)">
            <summary>
              Gets the proper modulus operation for
              a integer x and modulo m.
            </summary>
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.IntRange,AForge.IntRange,System.Int32)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.DoubleRange,AForge.DoubleRange,System.Double)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double,System.Double,System.Double[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Single,System.Single,System.Single,System.Single,System.Single[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double[],System.Double[],System.Double,System.Double,System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double[],System.Double[],System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.IntRange,AForge.DoubleRange,System.Int32)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Acosh(System.Double)">
            <summary>
              Returns the hyperbolic arc cosine of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Asinh(System.Double)">
            <summary>
            Returns the hyperbolic arc sine of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Atanh(System.Double)">
            <summary>
            Returns the hyperbolic arc tangent of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.FactorialPower(System.Int32,System.Int32)">
            <summary>
              Returns the factorial falling power of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.TruncatedPower(System.Double,System.Double)">
            <summary>
              Truncated power function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.InvSqrt(System.Single)">
            <summary>
              Fast inverse floating-point square root.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.StableSort``1(``0[],System.Comparison{``0})">
            <summary>
              Sorts the elements of an entire one-dimensional array using the given comparison.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Tools.Random">
            <summary>
              Gets a reference to the random number generator used
              internally by the Accord.NET classes and methods.
            </summary>
        </member>
        <member name="T:Accord.Math.ComparerDirection">
            <summary>
              Directions for the General Comparer.
            </summary>
            
        </member>
        <member name="F:Accord.Math.ComparerDirection.Ascending">
            <summary>
              Sorting will be performed in ascending order.
            </summary>
            
        </member>
        <member name="F:Accord.Math.ComparerDirection.Descending">
            <summary>
              Sorting will be performed in descending order.
            </summary>
            
        </member>
        <member name="T:Accord.Math.StableComparer`1">
            <summary>
              Stable comparer for stable sorting algorithm.
            </summary>
            
            <typeparam name="T">The type of objects to compare.</typeparam>
            
        </member>
        <member name="M:Accord.Math.StableComparer`1.#ctor(System.Comparison{`0})">
            <summary>
              Constructs a new instance of the <see cref="T:Accord.Math.StableComparer`1"/> class.
            </summary>
            
            <param name="comparison">The comparison function.</param>
            
        </member>
        <member name="M:Accord.Math.StableComparer`1.Compare(System.Collections.Generic.KeyValuePair{System.Int32,`0},System.Collections.Generic.KeyValuePair{System.Int32,`0})">
            <summary>
              Compares two objects and returns a value indicating
              whether one is less than, equal to, or greater than
              the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
            <returns>A signed integer that indicates the relative values of x and y.</returns>
            
        </member>
        <member name="T:Accord.Math.CustomComparer`1">
            <summary>
              Custom comparer which accepts any delegate or
              anonymous function to perform comparison of values.
            </summary>
            
            <typeparam name="T">The type of objects to compare.</typeparam>
            
        </member>
        <member name="M:Accord.Math.CustomComparer`1.#ctor(System.Func{`0,`0,System.Int32})">
            <summary>
              Constructs a new <see cref="T:Accord.Math.CustomComparer`1"/>.
            </summary>
            
            <param name="comparer">The comparer function.</param>
            
        </member>
        <member name="M:Accord.Math.CustomComparer`1.Compare(`0,`0)">
            <summary>
              Compares two objects and returns a value indicating
              whether one is less than, equal to, or greater than
              the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
            <returns>A signed integer that indicates the relative values of x and y.</returns>
            
        </member>
        <member name="T:Accord.Math.GeneralComparer">
            <summary>
              General comparer which supports multiple directions
              and comparison of absolute values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.GeneralComparer.#ctor(Accord.Math.ComparerDirection)">
            <summary>
              Constructs a new General Comparer.
            </summary>
            
            <param name="direction">The direction to compare.</param>
            
        </member>
        <member name="M:Accord.Math.GeneralComparer.#ctor(Accord.Math.ComparerDirection,System.Boolean)">
            <summary>
              Constructs a new General Comparer.
            </summary>
            
            <param name="direction">The direction to compare.</param>
            <param name="useAbsoluteValues">True to compare absolute values, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.GeneralComparer.Compare(System.Double,System.Double)">
            <summary>
              Compares two objects and returns a value indicating whether one is less than,
               equal to, or greater than the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
        </member>
        <member name="T:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver">
             <summary>
               Goldfarb-Idnani Quadratic Programming Solver.
             </summary>
             
             <remarks>
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://www.javaquant.net/papers/GoldfarbIdnani.pdf">
                   Goldfarb D., Idnani A. (1982) Dual and Primal-Dual Methods for Solving Strictly Convex Quadratic Programs.
                   Available on: http://www.javaquant.net/papers/GoldfarbIdnani.pdf .</a></description></item>
                 <item><description><a href="http://www.javaquant.net/papers/GoldfarbIdnani.pdf">
                   Berwin A Turlach. QuadProg, Quadratic Programming Solver (implementation in Fortran).
                   Available on:  http://school.maths.uwa.edu.au/~berwin/software/quadprog.html .</a></description></item>
               </list>
             </para>   
             </remarks>
             
             <example>
             <para>
               There are three ways to state a quadratic programming problem in this framework.</para>
               
             <list type="bullet">
               <item><description>
               The first is to state the problem in its canonical form, explicitly stating the
               matrix Q and vector d specifying the quadratic function and the matrices A and
               vector b specifying the problem constraints.</description></item>
               <item><description>
               The second is to state the problem with lambda expressions using symbolic variables.</description></item>
               <item><description>
               The third is to state the problem using text strings.</description></item>
             </list>
               
             <para>  
               In the following section we will provide examples for those ways. 
             </para>
             
             <para>
               This is an example stating the problem using lambdas:</para>
             <code>
             // Solve the following optimization problem:
             //
             //  min f(x) = 2x² - xy + 4y² - 5x - 6y
             // 
             //  s.t.   x - y  ==   5  (x minus y should be equal to 5)
             //             x  >=  10  (x should be greater than or equal to 10)
             //
            
             // In this example we will be using some symbolic processing. 
             // The following variables could be inicialized to any value.
             double x = 0, y = 0;
            
             // Create our objective function using a lambda expression
             var f = new QuadraticObjectiveFunction(() => 2 * (x * x) - (x * y) + 4 * (y * y) - 5 * x - 6 * y);
            
             // Now, create the constraints
             List&lt;LinearConstraint> constraints = new List&lt;LinearConstraint>();
             constraints.Add(new LinearConstraint(f, () => x - y == 5));
             constraints.Add(new LinearConstraint(f, () => x >= 10));
            
             // Now we create the quadratic programming solver for 2 variables, using the constraints.
             GoldfarbIdnaniQuadraticSolver solver = new GoldfarbIdnaniQuadraticSolver(2, constraints);
            
             // And attempt to solve it.
             double minimumValue = solver.Minimize(f);
             </code>
             
             <para>
               This is an example stating the problem using strings:</para>
             <code>
             // Solve the following optimization problem:
             //
             //  max f(x) = -2x² + xy - y² + 5y
             // 
             //  s.t.   x - y  ==   5  (x minus y should be equal to 5)
             //             x  >=  10  (x should be greater than or equal to 10)
             //
             //
            
             // Create our objective function using a text string
             var f = new QuadraticObjectiveFunction("-2x² + xy - y² + 5y");
            
             // Now, create the constraints
             List&lt;LinearConstraint> constraints = new List&lt;LinearConstraint>();
             constraints.Add(new LinearConstraint(f, "x - y ==  5"));
             constraints.Add(new LinearConstraint(f, "    x >= 10"));
            
             // Now we create the quadratic programming solver for 2 variables, using the constraints.
             GoldfarbIdnaniQuadraticSolver solver = new GoldfarbIdnaniQuadraticSolver(2, constraints);
            
             // And attempt to solve it.
             double maxValue = solver.Maximize(f);
             </code>
               
             <para>
               And finally, an example stating the problem using matrices:</para>
             <code>
             // Solve the following optimization problem:
             //
             //  min f(x) = 2x² - xy + 4y² - 5x - 6y
             // 
             //  s.t.   x - y  ==   5  (x minus y should be equal to 5)
             //             x  >=  10  (x should be greater than or equal to 10)
             //
             
             // Lets first group the quadratic and linear terms. The
             // quadratic terms are +2x², +3y² and -4xy. The linear 
             // terms are -2x and +1y. So our matrix of quadratic
             // terms can be expressed as:
            
             double[,] Q = // 2x² -1xy +4y²
             {   
                 /*           x              y      */
                 /*x*/ { +2 /*xx*/ *2,  -1 /*xy*/    }, 
                 /*y*/ { -1 /*xy*/   ,  +4 /*yy*/ *2 },
             };
            
             // Accordingly, our vector of linear terms is given by:
            
             double[] d = { -5 /*x*/, -6 /*y*/ }; // -5x -6y
            
             // We have now to express our constraints. We can do it
             // either by directly specifying a matrix A in which each
             // line refers to one of the constraints, expressing the
             // relationship between the different variables in the
             // constraint, like this:
            
             double[,] A = 
             {
                 { 1, -1 }, // This line says that x + (-y) ... (a)
                 { 1,  0 }, // This line says that x alone  ... (b)
             };
            
             double[] b = 
             {
                  5, // (a) ... should be equal to 5.
                 10, // (b) ... should be greater than or equal to 10.
             };
            
             // Equalities must always come first, and in this case
             // we have to specify how many of the contraints are
             // actually equalities:
            
             int numberOfEqualities = 1;
            
            
             // Alternatively, we may use a more explicitly form:
             List&lt;LinearConstraint> list = new List&lt;LinearConstraint>();
            
             // Define the first constraint, which involves only x
             list.Add(new LinearConstraint(numberOfVariables: 1)
                 {
                     // x is the first variable, thus located at
                     // index 0. We are specifying that x >= 10:
            
                     VariablesAtIndices = new[] { 0 }, // index 0 (x)
                     ShouldBe = ConstraintType.GreaterThanOrEqualTo,
                     Value = 10
                 });
            
             // Define the second constraint, which involves x and y
             list.Add(new LinearConstraint(numberOfVariables: 2)
                 {
                     // x is the first variable, located at index 0, and y is
                     // the second, thus located at 1. We are specifying that
                     // x - y = 5 by saying that the variable at position 0 
                     // times 1 plus the variable at position 1 times -1 
                     // should be equal to 5.
            
                     VariablesAtIndices = new int[] { 0, 1 }, // index 0 (x) and index 1 (y)
                     CombinedAs = new double[] { 1, -1 }, // when combined as x - y
                     ShouldBe = ConstraintType.EqualTo,
                     Value = 5
                 });
            
            
             // Now we can finally create our optimization problem
             var target = new GoldfarbIdnaniQuadraticSolver(numberOfVariables: 2, constraints: list);
            
             // And attempt to solve it.
             double minimumValue = target.Minimize(Q, d);
             </code>
             </example>
             
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.#ctor(System.Int32,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.LinearConstraint})">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of variables.</param>
            <param name="constraints">The problem's constraints.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.#ctor(System.Int32,System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Constructs a new instance of the <see cref="T:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of variables.</param>
            <param name="A">The constraints matrix <c>A</c>.</param>
            <param name="b">The constraints values <c>b</c>.</param>
            <param name="numberOfEqualities">The number of equalities in the constraints.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Maximize(Accord.Math.Optimization.QuadraticObjectiveFunction)">
            <summary>
              Maximizes the function.
            </summary>
            
            <param name="function">The function to be maximized.</param>
            <returns>The maximum value at the solution found.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Minimize(Accord.Math.Optimization.QuadraticObjectiveFunction)">
            <summary>
              Minimizes the function.
            </summary>
            
            <param name="function">The function to be minimized.</param>
            <returns>The minimum value at the solution found.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Minimize(System.Double[0:,0:],System.Double[])">
            <summary>
              Minimizes the function.
            </summary>
            
            <param name="hessian">The hessian matrix <c>D</c> for the quadratic terms.</param>
            <param name="linearTerms">The vector of linear terms <c>d</c>.</param>
            <returns>The minimum value at the solution found.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Maximize(System.Double[0:,0:],System.Double[])">
            <summary>
              Maximizes the function.
            </summary>
            
            <param name="hessian">The hessian matrix <c>D</c> for the quadratic terms.</param>
            <param name="linearTerms">The vector of linear terms <c>d</c>.</param>
            <returns>The maximum value at the solution found.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.NumberOfVariables">
            <summary>
              Gets the number of variables in the quadratic problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.NumberOfConstraints">
            <summary>
              Gets the total number of contraints in the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.NumberOfEqualities">
            <summary>
              Gets how many constraints are inequality constraints.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Iterations">
            <summary>
              Gets the total number of iterations performed on the
              last call to the <see cref="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Minimize(Accord.Math.Optimization.QuadraticObjectiveFunction)"/> method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Deletions">
            <summary>
              Gets the total number of constraint removals performed
              on the last call to the <see cref="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Minimize(Accord.Math.Optimization.QuadraticObjectiveFunction)"/> method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Lagrangian">
            <summary>
              Gets the Lagrangian multipliers for the
              last solution found.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Solution">
            <summary>
              Gets the last solution found on the last call
              to the <see cref="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Minimize(Accord.Math.Optimization.QuadraticObjectiveFunction)"/> method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Value">
            <summary>
              Gets the value found at the <see cref="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.ActiveConstraints">
            <summary>
              Gets the indices of the active constraints
              found at the last <see cref="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.ConstraintMatrix">
            <summary>
              Gets the constraint matrix <c>A</c> for the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.ConstraintValues">
            <summary>
              Gets the constraint values <c>b</c> for the problem.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Differentiation.FiniteDifferences">
            <summary>
              Derivative approximation by finite differences.
            </summary>
            <remarks>
            <para>
              Numerical differentiation is a technique of numerical analysis to
              produce an estimate of the derivative of a mathematical function or
              function subroutine using values from the function and perhaps other
              knowledge about the function.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                Trent F. Guidry, Calculating derivatives of a function numerically. Available on:
                http://www.trentfguidry.net/post/2009/07/12/Calculate-derivatives-function-numerically.aspx
                </description></item>
                </list>
             </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Differentiation.FiniteDifferences"/> class.
            </summary>
            
            <param name="variables">The number of free parameters in the function.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.#ctor(System.Int32,System.Func{System.Double[],System.Double})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Differentiation.FiniteDifferences"/> class.
            </summary>
            
            <param name="variables">The number of free parameters in the function.</param>
            <param name="function">The function to be differentiated.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.Reset">
            <summary>
              Resets the relative step sizes of the approximation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.Compute(System.Double[])">
            <summary>
              Computes the gradient at the given point <c>x</c>.
            </summary>
            <param name="x">The point where to compute the gradient.</param>
            <returns>The gradient of the function evaluated at point <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.derivative(System.Double[],System.Int32,System.Double)">
            <summary>
              Computes the derivative at point <c>x_i</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.createInterpolationCoefficients(System.Int32)">
            <summary>
              Creates the interpolation coefficients.
            </summary>
            <param name="points">The number of points in the tableau.</param>
            
        </member>
        <member name="P:Accord.Math.Differentiation.FiniteDifferences.Function">
            <summary>
              Gets or sets the function to be differentiated.
            </summary>
            
        </member>
        <member name="T:Accord.Math.ComplexExtensions.ComplexMatrix">
            <summary>
             Static class ComplexMatrix. Defines a set of extension methods
             that operates mainly on multidimensional arrays and vectors of
             AForge.NET's <seealso cref="T:AForge.Math.Complex"/> data type.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Abs(AForge.Math.Complex[])">
            <summary>
              Computes the absolute value of an array of complex numbers.
            </summary>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Sum(AForge.Math.Complex[])">
            <summary>
              Computes the sum of an array of complex numbers.
            </summary>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Multiply(AForge.Math.Complex[],AForge.Math.Complex[])">
            <summary>
              Elementwise multiplication of two complex vectors.
            </summary>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Magnitude(AForge.Math.Complex[])">
            <summary>
              Gets the magnitude of every complex number in an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Magnitude(AForge.Math.Complex[0:,0:])">
            <summary>
              Gets the magnitude of every complex number in a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Phase(AForge.Math.Complex[])">
            <summary>
              Gets the phase of every complex number in an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Re(AForge.Math.Complex[])">
            <summary>
              Returns the real vector part of the complex vector c.
            </summary>
            
            <param name="c">A vector of complex numbers.</param>
            <returns>A vector of scalars with the real part of the complex numers.</returns>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Im(AForge.Math.Complex[])">
            <summary>
              Returns the imaginary vector part of the complex vector c.
            </summary>
            <param name="c">A vector of complex numbers.</param>
            <returns>A vector of scalars with the imaginary part of the complex numers.</returns>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.ToArray(AForge.Math.Complex[])">
            <summary>
              Converts a complex number to a matrix of scalar values
              in which the first column contains the real values and 
              the second column contains the imaginary values.
            </summary>
            <param name="c">An array of complex numbers.</param>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Range(AForge.Math.Complex[])">
            <summary>
              Gets the range of the magnitude values in a complex number vector.
            </summary>
            
            <param name="array">A complex number vector.</param>
            <returns>The range of magnitude values in the complex vector.</returns>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.IsEqual(AForge.Math.Complex[][],AForge.Math.Complex[][],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.IsEqual(AForge.Math.Complex[],AForge.Math.Complex[],System.Double)">
            <summary>
              Compares two vectors for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="T:Accord.Math.Decompositions.LuDecomposition">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.LuDecomposition.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.#ctor(System.Double[0:,0:])">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Solve(System.Double[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.SolveTranspose(System.Double[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Solve(System.Double[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.CholeskyDecompositionD">
            <summary>
                Cholesky Decomposition of a symmetric, positive definite matrix.
            </summary>
            <remarks>
              <para>
                For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                lower triangular matrix <c>L</c> so that <c>A = L * L'</c>.
                If the matrix is not symmetric or positive definite, the constructor returns a partial 
                decomposition and sets two internal variables that can be queried using the
                <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionD.Symmetric"/> and <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionD.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.#ctor(System.Decimal[0:,0:])">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            <param name="value">The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square root free LDLt decomposition,
            false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square-root free LDLt decomposition,
            false otherwise.</param>
            <param name="lowerTriangular">True to assume the <paramref name="value">value
            matrix</paramref> is a lower triangular symmetric matrix, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[0:,0:])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is not symmetric and positive definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[0:,0:],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * x = b</c>.</summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Inverse">
            <summary>
              Computes the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.FromLeftTriangularMatrix(System.Decimal[0:,0:])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Symmetric">
             <summary>
               Returns <see langword="true"/> if the matrix is symmetric.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.PositiveDefinite">
             <summary>
               Returns <see langword="true"/> if the matrix is positive definite.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.LeftTriangularFactor">
             <summary>
               Returns the left (lower) triangular factor <c>L</c> so that <c>A = L * D * L'</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.DiagonalMatrix">
             <summary>
               Returns the block diagonal matrix of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Diagonal">
             <summary>
               Returns the one-dimensional array of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Determinant">
             <summary>
               Returns the determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.LogDeterminant">
             <summary>
               Returns the log-determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Nonsingular">
             <summary>
               Returns if the matrix is non-singular (i.e. invertible).
             </summary>
            
        </member>
        <member name="T:Accord.Math.Formats.MatrixFormatter">
            <summary>
              Defines how matrices are formatted and displayed, depending on the
              chosen format representation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Formats.MatrixFormatter.Format(System.String,System.Object,System.IFormatProvider)">
            <summary>
              Converts the value of a specified object to an equivalent string
              representation using specified formatting information.
            </summary>
            <param name="format">A format string containing formatting specifications.</param>
            <param name="arg">An object to format.</param>
            <param name="formatProvider">
              An <see cref="T:System.IFormatProvider"/> object that supplies
              format information about the current instance.</param>
            <returns>
              The string representation of the value of <paramref name="arg"/>,
              formatted as specified by <paramref name="format"/> and <paramref
              name="formatProvider"/>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Formats.MatrixFormatter.Format(System.String,System.Array,Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Converts a jagged or multidimensional array into a <a cref="T:System.String">System.String</a> representation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Formats.MatrixFormatter.parseOptions(System.String,System.String@,System.String@)">
            <summary>
              Parses a format string containing the format options for the matrix representation.
            </summary>
        </member>
        <member name="M:Accord.Math.Formats.MatrixFormatter.handleOtherFormats(System.String,System.Object,System.Globalization.CultureInfo)">
            <summary>
              Handles formatting for objects other than matrices.
            </summary>
        </member>
        <member name="M:Accord.Math.Formats.MatrixFormatter.ParseJagged(System.String,Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Converts a matrix represented in a System.String into a jagged array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Formats.MatrixFormatter.ParseMultidimensional(System.String,Accord.Math.Formats.IMatrixFormatProvider)">
            <summary>
              Converts a matrix represented in a System.String into a multi-dimensional array.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Combinatorics">
            <summary>
              Static class for combinatoric functions.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.TruthTable(System.Int32)">
             <summary>
               Generates all possible two symbol ordered
               permutations with repetitions allowed (a truth table).
             </summary>
             
             <param name="length">The length of the sequence to generate.</param>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.TruthTable(System.Int32,System.Int32)">
             <summary>
               Generates all possible ordered permutations
               with repetitions allowed (a truth table).
             </summary>
             
             <param name="symbols">The number of symbols.</param>
             <param name="length">The length of the sequence to generate.</param>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.Combinations``1(``0[],System.Int32)">
            <summary>
              Enumerates all possible value combinations
              of a given size for an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.Permutations``1(``0[])">
            <summary>
              Enumerates all possible value permutations for
              a given array.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.QuadraticConstraint">
            <summary>
              Constraint with only quadratic terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Double[0:,0:],System.Double[],Accord.Math.Optimization.ConstraintType,System.Double,System.Double)">
             <summary>
               Constructs a new quadratic constraint in the form <c>x'Ax + x'b</c>.
             </summary>
             
             <param name="objective">The objective function to which this constraint refers.</param>
             <param name="quadraticTerms">The matrix of <c>A</c> quadratic terms.</param>
             <param name="linearTerms">The vector <c>b</c> of linear terms.</param>
             <param name="shouldBe">How the left hand side of the constraint should be compared to the given <paramref name="value"/>.</param>
             <param name="value">The right hand side of the constraint equation.</param>
             <param name="withinTolerance">The tolerance for violations of the constraint. Equality
               constraints should set this to a small positive value. Default is 0.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticConstraint.QuadraticTerms">
            <summary>
              Gets the matrix of <c>A</c> quadratic terms
              for the constraint <c>x'Ax + x'b</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticConstraint.LinearTerms">
            <summary>
              Gets the vector <c>b</c> of linear terms
              for the constraint <c>x'Ax + x'b</c>.
            </summary>
            
        </member>
    </members>
</doc>
